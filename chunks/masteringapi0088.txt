results), and Q2, where you test to verify that the responses of the Attendee API are correct.      Contract Testing Versus Component Testing   If contract testing is not available, you should use API component tests to verify that your API conforms to your agreed interactions, i.e., your API specification. Using API component tests to verify that your API conforms to an interaction is not ideal—for a start, it is much more likely to be error-prone and is tedious to write. You should make contracts your golden source of agreed interactions, as the generated tests ensure that the shape of your API is accurate.      Case Study: Component Test to Verify Behavior   Let’s look at an example of a case for our Attendee API for the endpoint /conference/{conference-id}/attendees. This endpoint returns a list of the attendees at a conference event. For this component test, a mock is used to represent our external database dependency, and as seen in Figure 2-5, in this case that is the DAO.  Some things to test this endpoint for are:  Requests that are successful have response of 200 (OK)    Users without the right level of access will return a status of 403 (Forbidden)    When a conference has no attendees, an empty array will be returned      Figure 2-5. API Component test with mocked DAO      A library or testing framework that wraps a request client can be really useful. Here REST-Assured is used to call the Attendee API endpoint and to verify these test cases:11   @Test void