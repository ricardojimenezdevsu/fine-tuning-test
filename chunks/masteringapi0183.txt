traffic only, propagating context requires language support or shim    Security threat model  Library code runs as part of application  Sidecars typically share process and network namespace with application  Application interacts directly with OS via syscalls      Case Study: Using a Service Mesh for Routing, Observability, and Security   In this section of the chapter you will explore several concrete examples of how to use a service mesh to implement the common requirements of routing, observing, and securely segmenting (via authorization) your service-to-service traffic. All of these examples will use Kubernetes, as this is the most common platform on which service meshes are deployed, but the concepts demonstrated apply to all platforms and infrastructure for which each service mesh supports. Although we recommend choosing and adopting only one service mesh implementation within your application’s technology stack, we’ll demonstrate the configuration of the conference system using three different service meshes, purely for educational purposes.      Routing with Istio   Istio can be installed into your Kubernetes cluster with the istioctl tool. The main prerequisite for using Istio is enabling the automatic injection of the proxy sidecars to all services that are running within your cluster. This can be done as follows:   $ kubectl label namespace default istio-injection=enabled  With the auto-injection configured, the two primary Custom Resources you will be working