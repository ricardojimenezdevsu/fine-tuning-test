evolutionary architecture nicely, where we can control the rate of change to the new infrastructure we have presented so far in the book. Figure 5-1 shows how the the legacy system for attendees and the database will live side-by-side with the modernized API-based service. Using feature flags, the controller can now make a code-level decision about whether to execute the query against the internal or external API service.      Figure 5-1. Conference application container diagram for attendees and feature flags      Feature flags are typically hosted in a configuration store outside of the running application and allow code to be deployed with the feature off. Once the team (or product owner) is ready to enable the feature, they can toggle the feature on, which causes the application to execute a different branch of code. The granularity could be on a per-user level, or more coarse, as simply enabling a specific option globally. The following is example pseudocode from the popular Java feature-flagging tool LaunchDarkly, where the userâ€™s details are in the modern store:   LDUser user = new LDUser("jim@masteringapi.com"); boolean newAttendeesService = launchDarklyClient.boolVariation("user.enabled.modern", user, false); if (newAttendeesService) { // Retrieves the attendee from the modern store } else { // Retrieves the attendee from the legacy store }  Following this approach would allow you to migrate a small batch of users over to the new system and test that the