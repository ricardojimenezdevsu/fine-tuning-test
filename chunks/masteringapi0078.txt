Other tests are important and should be implemented as well, but these offer the most bang for the buck.      Note   It is important to note that contract testing is not the same as saying that an API conforms to a schema. A system is either compatible with a schema (like OpenAPI Spec) or it is not; a contract is about a defined interaction between parties and provides examples. Matt Fellows has an excellent piece on this titled “Schema-based contract testing with JSON schemas and Open API (Part 1)”.      How a Contract Is Implemented   As mentioned, a contract is a shared definition of how a producer and consumer interact. The following example shows a contract for a GET request to the endpoint /conference/{conference-id}/attendees. It states that the expected response has a property called value that contains an array of values about the attendees. In this sample definition of a contract, you can see that it is defining an interaction, which is used to generate the tests and stub server:   Contract.make { request { description('Get a list of all the attendees at a conference') method GET() url '/conference/1234/attendees' headers { contentType('application/json') } } response { status OK() headers { contentType('application/json') } body( value: [ $( id: 123456, givenName: 'James', familyName: 'Gough' ), $( id: 123457, givenName: 'Matthew', familyName: 'Auburn' ) ] ) } }  In Figure 2-4 you see how the generated tests are used by the consumer and producer.      Figure 2-4.