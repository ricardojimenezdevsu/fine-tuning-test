deployment looks roughly like the following steps:  Create a pull request of the changes required to the application, and once the pull request is approved and merged, automatically kick off the deployment build.    The build pipeline creates a new image using Docker or the Open Container Initiative.    Push the new image to the container registry.    Trigger a new deployment of the image into the target environment.      By default, Kubernetes will replace the running deployment with a new deployment. Later in this chapter we will look at techniques to phase in the release of a new pod to actively separate deployment and release. Once the deployment is in place, the job of deploying code is now complete, and a different set of instructions follow for the release configuration of the running system. The configuration may also have multiple stages, and this is a mechanism we can use to set up different release strategies. Before we dive into exploring how to structure the release for traffic management, it is worth exploring the types of releases that you can have within an API system.      Case Study: Modeling Releases in the Conference System   In “Semantic Versioning” (semver), we discussed the idea of different version strategies associated with APIs. When considering releases, it can be helpful to couple the ideas in semver with an API Lifecycle.      API Lifecycle   The API space is moving quickly, but one of the clearest representations of version lifecycle comes from