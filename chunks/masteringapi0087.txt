example differs from a contract test is that you should be checking that the service had the correct behavior; for example, if this was creating a new attendee, you want to verify that the service made a call to the (mocked) database. You are not just checking the shape of the response like contract tests do. As component tests verify multiple units together, they are (normally) slower running than unit tests. Component tests should not call out to external dependencies. Like contract testing, you are not using these tests to verify external integration points. The type of tests that you want to trigger in this scope varies based on the business case; however, for APIs you would be looking to validate cases such as:  Is the correct status code returned when a request is made?    Does the response contain the correct data?    Is an incoming payload rejected if a null or empty parameter is passed in?    When I send a request where the accepted content type is XML, will the data return the expected format?    If a request is made by a user who does not have the correct entitlements, what will the response be?    What will happen if an empty dataset is returned? Is this a 404 or is it an empty array?    When creating a resource, does the location header point to the new asset created?      From this selection of tests, you can see how these bleed into two areas of the test quadrant. This includes Q1, where you are confirming that the API being built works (i.e., it is producing