results. This is reaping the benefits of hindsight; adding pagination later and converting from an array to an object in order to add a @nextLink (as recommended by the standards) would break compatibility:   GET http://mastering-api.com/attendees --- 200 OK { "value": [ { "displayName": "Jim", "givenName": "James", "surname": "Gough", "email": "jim@mastering-api.com", "id": 1, } ], "@nextLink": "{opaqueUrl}" }      Filtering Collections   Our conference is looking a little lonely with only one attendee, however when collections grow in size we may need to add filtering in addition to pagination. The filtering standard provides an expression language within REST to standardize how filter queries should behave, based upon the OData Standard. For example, we could find all attendees with the displayName Jim using:   GET http://mastering-api.com/attendees?$filter=displayName eq 'Jim'  It is not necessary to complete all filtering and searching features from the start. However, designing an API in line with the standards will allow the developer to support an evolving API architecture without breaking compatibility for consumers. Filtering and querying is a feature that GraphQL is really good at, especially if querying and filtering across many of your services becomes relevant.      Error Handling   An important consideration when extending APIs to consumers is defining what should happen in various error scenarios. Error standards are useful to define upfront and share with