system. Even that is locked down. You need to start to enable a few controlled scenarios in the platform to remain locked down, but still allow the service mesh to operate. In the following policy, we allow DNS lookup on the legacy conference system, in order for it to locate the Attendee service:   --- apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-dns spec: podSelector: matchLabels: app: legacy-conference policyTypes: - Egress egress: - ports: # allow DNS resolution - port: 53 protocol: UDP ---  At this point the service mesh legacy conference service can discover where the attendees are via the sidecar, however the request itself would be blocked. Every routing rule in service mesh needs a corresponding allow rule defined in the network policy adapter. In this final example, we open up the rule for the legacy conference system to communicate with the Attendee service:   --- apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-conference-egress spec: podSelector: matchLabels: app: legacy-conference policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: kubernetes.io/metadata.name: attendees  For ingress to work, you would also need to add ingress rules from the service mesh gateway through to the target services. In “Application Decisions for Effective Software Releases”, we outlined application-level decisions for an opinionated platform. Ensuring that the rules and configuration are applied in a consistent