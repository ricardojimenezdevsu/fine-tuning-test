metadata: name: legacy-conference spec: hostname: "*" prefix: / rewrite: / service: conferencesystem.legacy:8080  Another Mapping can be added to route any traffic sent to the “/attendees” path to the new (“nextgen”) attendees microservice that has been extracted from the monolith. The information included in the Mapping should look familiar from the previous example. Here a rewrite is specified that “rewrites” the matching prefix path in the URL metadata before making the call to the target Attendee service. This makes it appear to the Attendee service that the request originated with the “/” path, effectively stripping out the “/attendees” part of the path.   --- apiVersion: getambassador.io/v3alpha1 kind: Mapping metadata: name: legacy-conference spec: hostname: "*" prefix: /attendees rewrite: / service: attendees.nextgen:8080  This pattern of creating additional Mappings as each new microservice is extracted from the legacy application can continue. Matching prefixes can be nested (e.g., /attendees/affiliation), or use regular expressions (e.g., /attendees/^[a-z].*"). Eventually the legacy application becomes a small shell with only a handful of functions, and all of the other functionality is handled by microservices, each with their own Mapping.      Configuring Mappings Using Host-based Routing   Most API gateways will also let you perform host-based routing (e.g., host: attendees.conferencesystem.com). This can be useful if you need to create a new domain or subdomain