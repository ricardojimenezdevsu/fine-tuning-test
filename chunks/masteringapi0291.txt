implementation-specific data model or schema.      End State Architecture Options   As you evolve and redesign your monolithic applications and APIs, you should have a clear vision of what you want your system to be able to do as a result of the changes being made. Otherwise, this now infamous scene in Alice in Wonderland will become all too true:  “Would you tell me, please, which way I ought to go from here?” “That depends a good deal on where you want to get to,” said the Cat. “I don’t much care where—” said Alice. “Then it doesn’t matter which way you go,” said the Cat. “—so long as I get SOMEWHERE,” Alice added as an explanation.  You will learn more about the approach to determining your overall goals for evolving systems in the next section of this chapter, but for the moment let’s take a tour of the potential options for your architecture and how they impact API design.      Monolith   Over the last several years, the monolithic architectural style has gotten a bad rap. However, this is mostly because the word “monolith” has become synonymous with “big ball of mud.”1 In reality, a monolith is just a software system that is composed all in one piece and runs as a single-process, self-contained application. There is nothing fundamentally wrong with a monolithic architecture. For many systems, particularly proof of concept applications, or systems that are being created as the underlying business product market fit is being found, this architectural style will allow you