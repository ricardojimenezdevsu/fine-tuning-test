/attendees was using a proxy, which now bounces, producing 500s everywhere. It turns out the cached result was masking the fact that our new software was broken.  To avoid caching results it is important to set a header on the client making the GET request, i.e., Cache-Control: no-cache, no-store. Eventually the cache will expire and we achieve a consistent state.      Application-Level Header Propagation   Any API services that terminate an API request and create a request to another service need to copy headers across from the terminated request to the new request. For example, any tracing- or observability-related headers need to be added on to the downstream request to ensure distributed tracing is observed.  For authentication and authorization headers, it is important to have an opinion on what can safely be sent downstream. For example, forwarding an authentication header can end up with a service being able to impersonate another service or user, causing issues. An OAuth2 bearer token, however, is safe to send downstream (as long as the transport is secure).      Logging to Assist Debugging   Things are going to go wrong in a distributed architecture! Often, being able to see that a request made it to a service is really valuable, especially if you donâ€™t consider caching. It is useful to think of logs in two different types: journal and diagnostics. A journal allows the capturing of important transactions/events within the system and is used sparingly. An example of a