some form of automated entity database serialization/deserialization, as often provided by object-relational mapping (ORM) frameworks.  Letâ€™s examine a hypothetical case for our Attendee API. Imagine that there is a property called devices that is returned when making a request for an attendee. This property is designed to be an externally read-only list of devices that the attendee has used to connect to the API, and this should only be updated by the attendee application code.  A bad actor makes a GET request for an attendee (/attendees/123456) and receives the following response:   { "name": "Danny B", "age": 35, "devices": [ "iPhone", "Firefox" ] }  Now the bad actor issues a PUT request to the Attendee API to update the age attribute, and they also maliciously attempt to update the devices list:   PUT /attendees/123456 { "name": "Danny B", "age": 36, "devices": [ "vulnerableDevice" ] }  Any data in the devices list should be ignored when the entity is saved to the database. Mass Assignment is typical where client input data is bound to internal objects without thought of the repercussions, which is often a consequence when exposing a database API as a web-based API. In Chapter 1 the concerns of exposing an underlying data model are discussed from a usability point of view, which provides additional reasons not to do this.  This vulnerability is not something that can typically be solved at the API gateway level; instead, this must be guarded against within the API