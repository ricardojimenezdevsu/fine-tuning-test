response_for_attendees_should_be_200() { given() .header("Authorization", VALID_CREDENTIAL) .when() .get("/conference/conf-1/attendees") .then() .statusCode(HttpStatus.OK.value()); } @Test void response_for_attendees_should_be_403() { given() .header("Authorization", INVALID_CREDENTIAL) .when() .get("/conference/conf-1/attendees") .then() .statusCode(HttpStatus.FORBIDDEN.value()); ... }  Running this type of test gives us confidence that our API is behaving correctly.      API Integration Testing   Integration tests in our definition are tests across boundaries between the module being developed and any external dependencies. Integration tests are a type of service test and can be seen in the test pyramid image in Figure 2-3.  When performing integration testing, you want to confirm that the communication across the boundary is correct; i.e., your service can correctly communicate with another service that is external to it.  The types of things you want to verify are the following:  Ensuring that an interaction is being made correctly; e.g., for a RESTful service, this may be specifying the correct URL or that the payload body is correct.    Can the unit that is interacting with an external service handle the responses that are being returned?      In our case the legacy conference system needs to verify that it can make a request to the new Attendee API and can interpret the response.      Using Stub Servers: Why and How   If you are using contract tests, the generated stub