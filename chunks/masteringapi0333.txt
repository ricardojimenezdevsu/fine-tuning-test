introduced a facade pattern, allowing control over when the legacy service is called versus the modern service.      Figure 10-3. Adding an API gateway to the conference system      We took this one step further in Chapter 4, by extracting the conference session functionality from the legacy conference system into a new Session service, and introducing a service mesh to handle the service-to-service API traffic. At this point in the case study, the architecture looked like Figure 10-4.      Figure 10-4. C4 Model showing the extraction of the Session service from the conference system      With a focus toward incrementally releasing API-based services in Chapter 5, we created an internal and external version of the Attendee service and used feature flags to determine which service a userâ€™s request was routed to. Figure 10-5 shows the two Attendee services side-by-side within the static architecture diagram.      Figure 10-5. C4 model showing two Attendee services being routed to via feature flags      In Chapter 6 we focused on security, and although the architecture remained static, we introduced the concept of a mobile application calling the conference system, as shown in Figure 10-6, in order to provide a realistic scenario to conduct threat modeling.      Figure 10-6. C4 architecture showing a mobile app interacting with the conference system      Chapter 7 added an external CFP system to the architecture, as shown in Figure 10-7, which required the implementation of