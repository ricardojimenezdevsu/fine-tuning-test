Chapter 9. Using API Infrastructure to Evolve Toward Cloud Platforms

In the previous chapter we provided an overview of architectural approaches that you can use when evolving APIs and the services that power them. An equally important topic to consider within the evolution of systems is the underlying infrastructure, platforms, and hardware. Often this changes and evolves on its own rhythm: as hardware breaks, companies and technology become merged or acquired, or organization-wide IT policies dictate that infrastructure be upgraded. However, at times an API program will drive infrastructure changes, particularly in relation to modernization and moving to more cloud-like (software-defined) infrastructure. Now, you will learn how to implement and manage evolving a system and the corresponding API infrastructure. This chapter builds on the architecture foundations presented in the previous chapters and explores how you can use API infrastructure, such as API gateways, service meshes, and developer portals, to evolve a system when moving to a cloud-based environment. You will learn the differences between a “lift and shift” of applications, a “replatform,” and a “refactor or re-architecture,” and develop the skills to know which is the most appropriate given a specific context. The accompanying case study will show how the existing API gateway and the Attendee service can be migrated to the cloud. The use of an API gateway can provide location transparency for services and APIs being served, which allows the deployment of a service into the cloud and traffic to be gradually shifted from the existing service to the new with limited (or no) impact on consumers. You will also explore nascent migration options for migrating services to the cloud using the multilocation/cluster functionality of a service mesh.
Case Study: Moving the Attendee Service to the Cloud For the next evolution of the conference system case study, you will focus on moving the Attendee service to a cloud vendor’s infrastructure. The primary motivation for doing this is that conference system owners want to eventually remove the burden of running their own data center. This will ultimately involve moving all of the new services, the monolithic application, middleware (such as API gateways), and datastores, to the cloud. We’ve chosen to migrate the Attendee service first, as it is the newest component and also one of the services that receives the most traffic. Figure 9-1 shows how the extracted Attendee service is currently running outside of the main conference system application’s context.
Figure 9-1. C4 model showing the extracted Attendee service
As you will explore in this chapter, there are multiple approaches to moving this service and supporting infrastructure to the cloud. Before you dive into the mechanics of the preceding approach, let’s first explore the options that we should consider before deciding on the migration strategy.
Choosing a Cloud Migration Strategy Building on Gartner’s 2010 article, “Migrating Applications to the Cloud: Rehost, Refactor, Revise, Rebuild, or Replace?” Amazon Web Services published a blog in 2016 that presented the “six Rs” of cloud migration.1 These articles are a great jumping-off point if you have been tasked with evaluating or leading a migration of your existing architecture and systems to the cloud. As APIs are often the closest business-driven component to the user—and a key point of ingress for the majority of requests—you should pay special attention to them when deciding on your approach to migration. The six Rs present a spectrum of options from “do nothing” all the way through to a complete rebuild or retiring of a system. They are: Retain or RevisitRehostReplatformRepurchaseRefactor/Re-architectRetire
Let’s examine AWS’s six Rs in more detail and explore how you can use this framework to evolve API infrastructure.
Retain or Revisit This is the do nothing (for now) strategy. Although it can be tempting to discount this approach, many architects (us included) will suggest you “pick your battles,” and sometimes the battle of migrating an API is not worth the return on your effort. This decision should, of course, be based on a sound business and technical evaluation, and you should communicate the decision to not take action internally and externally as appropriate. This is where ADRs shine—in terms of providing the paper trail and rationale of these decisions for future reference.
Communicating Change and Deprecations A business and technical evaluation of a current API or system may lead you to decide against evolving the system at the current time. In this situation, it’s still important to communicate any known dates by which action must be taken. For example, if a business unit is shutting down on a known date, or a system will reach end-of-life (EOL), or a key software or datastore license will expire at a known time, this should be communicated to consumers as a deprecation warning. You will most likely have a required deprecation notice baked into contracts and SLAs, and so be sure to consult these.One key factor when considering moving applications to the cloud is the introduction of latency between two services during evolutionary steps. If you have a high-traffic service, a slowdown will be incurred for each request when crossing network boundaries. Ensuring that there is an understanding of what the degradation looks like is an important consideration, and if this violates an SLA, moving the service may not be an option. In “Modeling Exchanges and Choosing an API Format”, you learned how to choose a protocol and design an API within constraints, which is an important consideration when crossing boundaries. Retaining would not be a viable strategy for our conference use case, as this would simply be “kicking the can down the road” and deferring the goal of migrating to the cloud.
Rehost “Rehost” is otherwise known as “lift-and-shift.” It involves moving systems and workloads to a cloud platform without any re-architecting. If you are looking to consolidate workloads or simply have to migrate away from your current infrastructure, this can often be an effective strategy. However, be aware that cloud infrastructure does not always behave in the same way as on-premise hardware, and so identify and confirm any assumptions that you have made.
Be Cautious with Specialist Systems and Bespoke Hardware Although many “lift-and-shift” projects work as expected, some don’t. This is especially true in relation to specialist bespoke systems and custom hardware. For example, older specialist systems may assume that all communication within the system occurs over a local bus or dedicated network connections (which isn’t the case in the cloud), and certain datastore technologies assume specific hardware characteristics (or guarantees) of the underlying block storage system. When in doubt, do your research.Rehosting could be a viable approach for our case study, although we have chosen the option of replatforming to allow us to take advantage of some cloud features.
Replatform This approach is sometimes referred to as “lift-tinker-and-shift.” It is very similar to rehosting but also takes advantage of some cloud services that require minimal re-work. For example, an existing datastore that is run as a system component may be swapped out for a protocol-compatible cloud service. You could swap a native MySQL datastore with a MySQL-compatible AWS RDS, an Azure Database, or GCP Cloud SQL. Another common replatforming is to update or change a language-specific application server or container. This is the approach we have chosen for our conference system case study, so we can avoid major rework while still taking advantage of new cloud services as we migrate away from our existing on-premise infrastructure.
Repurchase Repurchase primarily involves moving to a different product—for example, subscribing to a SaaS-based email-sending service rather than continuing to run an email server in-house. As our conference system example primarily consists of bespoke applications and standard datastores, there is no option to repurchase (other than perhaps purchasing an off-the-shelf conference management system, which is out of scope for the migration).
Refactor/Re-architect Refactoring means a re-imagining of how the application is architected and developed, typically using cloud native features. As with any refactor, the core (external) functionality of the application or system should not change, but how the functionality is accomplished internally will definitely change. This is typically driven by a strong business need to add features, scale, or performance that would otherwise be difficult to achieve in the application’s existing environment. For example, if an organization has decided to decompose an existing monolithic application into microservices, a move toward adopting cloud native patterns is very often also considered. This pattern tends to be the most expensive to implement, but, if you have a good product-market fit and are being limited by your existing technology choices, it can also be the most beneficial. We have not explicitly chosen this approach for our case study, as you have already been re-architecting the conference system throughout this book. One important point to consider is that API infrastructure and design lead toward a more cloud native way of thinking. Defining and modeling APIs as discussed in Chapter 1 facilitates a neat mechanism for representing services during refactor/re-architecture. It is also key that many cloud-based services or interactions are based on APIs too. The strategy around APIs when re-architecting is just as important as the service and systems that you plan to use on the cloud. With the re-architecture now complete, it makes the most sense to replatform onto the cloud before making additional changes to the architecture.
Retire “Retiring” systems during a migration simply means that you get rid of them. During many large migrations we have taken part in, there is often at least one existing system that is not being used any more and has simply been forgotten. As there is no longer a need for this functionality, the system can simply be decommissioned and the hardware resource freed or recycled. It goes without saying that, as our conference system is relatively small and cohesive, there are no parts of it that can be retired quite yet! One of the overall goals was to retire the legacy conference system, and once the replatforming and refactoring is complete we can move forward with this.
Case Study: Replatforming the Attendee Service to the Cloud Given the context provided in the previous section of this chapter, we have decided to “replatform” our Attendee service in addition to migrating the API gateway to the cloud. Retaining or retiring the service were not valid options, given the requirements to migrate toward the cloud. Repurchasing also did not make sense in this context. As we have already re-architected the attendees’ functionality, by extracting this to a service early in this book, the refactor/re-architect did not appear appropriate. However, when you are adding new functionality into the conference system in the future, re-architecting the system (potentially extracting a service) and moving this to the cloud would be an option to strongly consider. Rehosting could be a solid strategy, but we are keen to take advantage of a cloud-based database-as-a-service rather than “lift and shift” our own MySQL database instance. As shown in Figure 9-2, the “replatforming” approach will provide a good foundation on which to continue the migration as we move more services to the cloud. Moving the API gateway to the cloud now will also help to support API traffic being incrementally routed from the existing on-premises location to the cloud. Figure 9-2 shows the final state of the replatformed architecture.
Figure 9-2. Infrastructure diagram showing extracted API gateway and Attendee service
Let’s now consider how you could implement other requirements, such as API management, as the conference system evolves.
Role of API Management Regardless of the strategy taken for your evolutionary journey, API management can play a key role in migration and also in unlocking the value of APIs across and even outside of an organization. API managers are essentially a supercharged gateway at the heart, providing a wide variety of additional features for publishing and controlling APIs. API managers provide policies that enable edge concerns, such as OAuth2 challenges, content validation, rate limiting, throttling, and many other features that are typical in a gateway. Additionally, they can provide developer portals containing a marketplace of all APIs that developers can use when building systems to consume offered APIs. Organizations can also use API management to monetize accessing APIs, both to external customers and for internal “chargebacks,” which are common in enterprises and cross-divisional deployments. In “Current API Gateway Taxonomy”, we shared taxonomies for API gateways, and API management sits within the enterprise gateway category. Perhaps the most important part of API management is that it can offer a central point to discover APIs, while you continue to make changes behind the scenes. It is possible to front the legacy conference system with an API, for example, while also offering the new broken-out Attendee API. In the case of the conference organizers, they could potentially look at offering an API that provides “conference management as a service” that would allow other conferences to use this, or to interface in a controlled manner with the external CFP system. Assuming that contracts on the API don’t change, it is possible to evolve behind an API management layer. Organizations often talk about the concept of being API First, meaning that all interactions between systems are carefully designed and modeled as APIs. This was a concept that we explored in Chapter 1. By following good design principles and striving for “API-First” design, this enables you to unlock value both externally to customers or internally within the wider organization by using tools like API management. To modernize and migrate applications to be able to take advantage of using a tool like external API management, you need to reconsider traffic patterns. As architecture evolves to become hybrid, spanning different networks and deployments, thoughts about traffic also needs to be challenged.
North–South Versus East–West: Blurring Lines of Traffic Management With a tour of the various options available for an API infrastructure migration complete, let’s now explore how our chosen approach to replatforming will impact the management of API traffic within the evolving conference system. As we have chosen to incrementally migrate our services—rather than risk a big bang—the running of services across multiple cloud environments and on-premise data centers does present additional challenges. As is the case with many incremental cloud migrations, traffic will need to transit multiple networks in order to satisfy an API request made by a user.
Start at the Edge and Work Inward In our case study, we have chosen to start at the edge by migrating the API gateway to the cloud along with a single service. Doing this can provide a migration team the chance to initially set up a completely new cloud environment without disrupting the existing system. For example, a duplicate of the current API gateway can be deployed into the cloud while the existing gateway is left running as is. This enables you to minimize risk by incrementally configuring the cloud-based API gateway without disrupting the existing production system. It is often sensible to build an isolated proof of concept purely within the cloud, and only when this has been verified, start experimenting with routing into and out of the cloud environment. Designing for cloud-based architectures is often a paradigm shift from a design perspective. Don’t underestimate the time needed to learn and understand new infrastructure.
Crossing Boundaries: Routing Across Networks Before a migration to the cloud can go live, it is often necessary to ensure that the new and old systems can interact across the different networks. As discussed in Chapters 3 and 4, you have a range of options to implement this routing. If there is a single monolithic application and a small number of simple routes, it can be easiest to temporarily route from the new API gateway to the old, potentially with a simple HTTP redirect. However, if there are a large number of routes that will cross networks, or traffic must not leave the network once it has entered, you will have to consider other options, such as virtual private network peering or endpoints, or multicluster service mesh. With API traffic transiting multiple networks, you will most likely need to consult your InfoSec teams, as this will disrupt the traditional approach to perimeter defenses and zonal architecture. Let’s explore this topic in more depth and learn how the move to zero trust networks can help.
From Zonal Architecture to Zero Trust Before learning how modern API gateways and service meshes can help you implement zero trust networks, let’s first explore the traditional approach to zonal network architecture.
Getting in the Zone As the commercial internet grew in popularity, more and more regulated industries began providing access to applications. This meant that both new systems and existing internal systems were made to be user facing. The emergence of zonal architectures provided a best practice in designing secure networks. Zoning is used to mitigate the risk of a completely open or flat network by segmenting infrastructure services into logical groupings that have the same networking security policies and security requirements. Consider a vulnerability like Log4Shell (CVE-2021-44228), a zero-day vulnerability posing significant risk to Java applications using affected Log4J libraries. Using the exploit, an attacker could gain access to a host in a network and start to run malicious activities. The range of impact and services under exploit is known as the blast radius of the attack. If all untrusted requests enter a zone that has access to very little high-value information, the blast radius is minimized and security operations have time to act to prevent serious outage. Zones tend to cascade, with each traversal into the next zone applying more defense-in-depth mitigation to challenge the inbound traffic. The zones are separated by perimeters (Zone Interface Points) implemented through security and network devices. Zoning is a logical design approach used to control and restrict access and data communication flows only to those components and users as per security policy. There are many approaches to defining zones and the associated security requirements, both standardized (often at the country level) and bespoke. However, as shown in Figure 9-3, four typical zones are found in most zonal architectures:2
Figure 9-3. A typical zonal architecture, taken from the Canadian government’s ITSG-22
Public Zone (PZ) This zone is entirely open and includes public networks such as the public internet, the public switched telephone network, and other public carrier backbone networks and services.Public Access Zone (PAZ) This zone mediates access between operational systems and the Public Zone and often includes a demilitarized zone (DMZ).Operations Zone (OZ) An OZ is the standard environment for routine operations and with appropriate security controls at the end systems. This zone may be suitable for processing sensitive information; however, it is generally unsuitable for large repositories of sensitive data or critical applications without additional strong, trustworthy security controls that are beyond the scope of this guideline.Restricted Zone (RZ) This zone provides a controlled network environment generally suitable for business-critical IT services or large repositories of sensitive information and supports access from systems in the Public Zone via a PAZ and an OZ.
This approach to perimeter-based network design is somewhat similar to the old “castle and moat” defense, in that an attacker will struggle the most at the ingress point, but once inside the castle walls, they will generally have an easier time navigating around. This is largely because assumptions are made about any communication originating from within the system perimeter, network, or location. However, cloud infrastructure can challenge these assumptions. In many cloud platforms, the geographical and network location of the underlying infrastructure is abstracted away or not available. Even with protections in place from cluster providers, there is still the risk of a supply chain attack, where software is manipulated with malicious content at build time. Another possibility is a malicious user at the infrastructure provider’s site, accessing information from the platform level. Running different types of security across different types of deployment is possible, however a more homogeneous approach reduces the risk of assumptions being made and the requirement to learn different security techniques. There is inherent trust designed into a zone-based architecture, which prompted the evolution of a new approach: that of zero trust.
Trust No One and Verify The zero trust security model, also known as zero trust architecture or perimeterless security, describes an approach to the design and implementation of modern network systems. The main concept behind the zero trust security model is “never trust, always verify,” which means that devices should not be trusted by default, even if they are connected to a permissioned network such as a corporate LAN and even if they were previously verified. The reasoning for zero trust is that the traditional approach—trusting devices within a notional “corporate perimeter,” or devices connected via a VPN—is not relevant in the complex environment of a corporate network. The zero trust approach advocates mutual authentication, including checking the identity and integrity of devices without respect to location, and providing access to applications and services based on the confidence of device identity and device health in combination with user authentication. The eight principles outlined in our guidance will help you to implement your own zero trust network architecture in an enterprise environment. The principles are: Know your architecture, including users, devices, services, and data.Know your user, service, and device identities.Assess your user behavior, device, and service health.Use policies to authorize requests.Authenticate and authorize everywhere.Focus your monitoring on everything in regard to access: users, devices, and services.Don’t trust any network, including your own.Choose and design services for zero trust.
The eight principles outlined are perfectly reasonable, however they are very tricky to consider in zonal architecture. The concept of a zone’s trust assumptions would challenge many of these points. For example, a zonal architecture often only authenticates a user once at the edge of the system, and all networks within the perimeter are trusted by default. Let’s explore how we can potentially evolve to a zero trust–based architecture.
Role of Service Mesh in Zero Trust Architectures Zero Trust Architecture, published by NIST in 2020, is a fantastic document in defining zero trust and key architectural considerations. Service mesh and API gateways combined provide a fantastic platform for implementing zero trust–based architectures. Using service mesh helps provide a homogeneous modeling of how your architecture components are represented and how the traffic flows between them. Underlying technologies enable a concrete model around running process identity and management of certificates helps to assert and prove identity. Integration of active tracing and monitoring enables analysis at all points in the platform, both for users but also for underlying services and Kubernetes pod health. All ingress traffic must have a strong challenge, often asserting that request with OAuth2 as discussed in Chapter 7, and traffic within the cluster can use mTLS for a strong assertion of authentication and authorization. Don’t trust any network, including your own is an interesting challenge for service mesh. In most service mesh models, a sidecar is tightly coupled with a service or app, enabling traffic management and security by routing via the sidecar. However, the simplicity of this deployment means that you cannot make concrete assertions on the platform that you are running on. What sits under the application and the sidecar needs to be secured to not make trust-based assumptions.
Augmenting Service Mesh with Network Policies Platform security underpins any assumptions that you make at the application level. You therefore need to move down a level to get full zero trust. Kubernetes has the concept of NetworkPolicies allowing the use of a network plug-in, such as Calico. The controls allow you to create an isolation of pods from the platform that they operate on. For example, the following policy will lock down all inbound and outbound traffic from being able to enter a given pod. For a zero trust architecture, this would be the default for pods; by applying the rule, the pod becomes fully isolated: --- apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default-deny-all spec: podSelector: {} policyTypes: - Egress - Ingress Service mesh implementations often rely on looking up service names using a central DNS system. Even that is locked down. You need to start to enable a few controlled scenarios in the platform to remain locked down, but still allow the service mesh to operate. In the following policy, we allow DNS lookup on the legacy conference system, in order for it to locate the Attendee service: --- apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-dns spec: podSelector: matchLabels: app: legacy-conference policyTypes: - Egress egress: - ports: # allow DNS resolution - port: 53 protocol: UDP --- At this point the service mesh legacy conference service can discover where the attendees are via the sidecar, however the request itself would be blocked. Every routing rule in service mesh needs a corresponding allow rule defined in the network policy adapter. In this final example, we open up the rule for the legacy conference system to communicate with the Attendee service: --- apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-conference-egress spec: podSelector: matchLabels: app: legacy-conference policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: kubernetes.io/metadata.name: attendees For ingress to work, you would also need to add ingress rules from the service mesh gateway through to the target services. In “Application Decisions for Effective Software Releases”, we outlined application-level decisions for an opinionated platform. Ensuring that the rules and configuration are applied in a consistent manner at release time is another reason to consider an opinionated platform. By using service mesh and network policies, you have learned how to created a microsegmented architecture. The benefit of this approach is that you can have a scenario whereby security is consistent in a hybrid architecture with both the cloud and environments that were formerly zonal-based. A common pattern that is emerging is using a service mesh to bridge different (“multicluster”) networks. This is accomplished via the use of peering service meshes together across the clusters, bringing the on-premises and cloud data plane under the knowledge of a combined control plane.3 In Figure 9-4 the service mesh is responsible for all routing and can provide a zero trust architecture across networks. The advantage of taking this route is that it leads to a secure evolutionary architecture and homogeneous security environment. By making on-premises work like the cloud, there is now an easy path to evolving the remaining services into the cloud.
Figure 9-4. Multicluster service mesh peering
Summary In this chapter you have learned how the use of API infrastructure, such as API gateways, service meshes, and developer portals, can be used to evolve a system when moving to a cloud-based environment: There are a number of approaches to evolving or migrating an API-based system toward the cloud, ranging from retain (“do nothing”), to rehost, replatform, repurchase, refactor/re-architect (rewriting to take advantage of cloud infrastructure), and retire.When migrating an API application to the cloud, you will often find that the line between north–south (ingress) and east–west (service-to-service) traffic management blurs.An API gateway can be used as a tool for migration, as it can encapsulate functionality and act as a facade for multiple backend systems operating from different environments and networks.The industry is moving away from zonal network architectures to “zero trust” systems, and service mesh technology can facilitate this move.Adopting zero trust allows you to combine both zero trust and zonal architectures, which helps with bridging cloud and on-premises systems during a migration period.
With your journey through the landscape of API architecture almost complete, the next and final chapter wraps up the key concepts and provides a look to the future in this space.
1 See “6 Strategies for Migrating Applications to the Cloud”. 2 Interested readers can learn more about zonal architectures from the Canadian government’s Network Security Zoning. 3 The mechanics of this varies for each service mesh implementation.
Chapter 10. Wrap-up In the previous nine chapters of this book, you have undertaken a journey covering everything from designing APIs, to implementing, securing, and operating them. The focus has been on architecture, but just as important is how you apply architecture within your organization. In this final chapter of the book, you will explore emerging API technologies that may play a bigger role in the future and learn how we keep up-to-date with these changing best practices, tools, and platforms.
Case Study: A Look Back on Your Journey Throughout the book, we have been making evolutionary steps to update and mature the conference system architecture use case that we began with. You can see the starting point in Figure 10-1.
Figure 10-1. Original conference system architecture
Let’s look at some of the decisions taken in extracting the Attendee service. As shown in Figure 10-2, and discussed in the Introduction, we made the decision (based on requirements from the conference system stakeholders) to extract the attendees, functionality into an API-based service that would be run as a standalone process external from the legacy conference system.
Figure 10-2. Extracting the Attendee service from the conference system
In Chapters 1 and 2, the architecture remained static while we explored how to design and test the Attendee API and service. In Chapter 3 we took our first big evolutionary step, introducing an API gateway between the end-user customer and the existing conference system and new service. As shown in Figure 10-3, the customer now makes requests to the conference system via the API gateway, which provides an abstraction and single point of entry for traffic bound to either the legacy conference system or the new Attendee service. This step introduced a facade pattern, allowing control over when the legacy service is called versus the modern service.
Figure 10-3. Adding an API gateway to the conference system
We took this one step further in Chapter 4, by extracting the conference session functionality from the legacy conference system into a new Session service, and introducing a service mesh to handle the service-to-service API traffic. At this point in the case study, the architecture looked like Figure 10-4.
Figure 10-4. C4 Model showing the extraction of the Session service from the conference system
With a focus toward incrementally releasing API-based services in Chapter 5, we created an internal and external version of the Attendee service and used feature flags to determine which service a user’s request was routed to. Figure 10-5 shows the two Attendee services side-by-side within the static architecture diagram.
Figure 10-5. C4 model showing two Attendee services being routed to via feature flags
In Chapter 6 we focused on security, and although the architecture remained static, we introduced the concept of a mobile application calling the conference system, as shown in Figure 10-6, in order to provide a realistic scenario to conduct threat modeling.
Figure 10-6. C4 architecture showing a mobile app interacting with the conference system
Chapter 7 added an external CFP system to the architecture, as shown in Figure 10-7, which required the implementation of external (user-facing) authentication and authorization.
Figure 10-7. External system communicating with the conference system
In Chapter 9 we focused on migrating the Attendee service and API gateway to a cloud platform, which resulted in the architecture shown in Figure 10-8.
Figure 10-8. Cloud migration to conference system
Finally, in Chapter 9 we provided a potential model for migrating toward a zero trust architecture, with a uniform approach to deployment, routing, and security. In Figure 10-9 there is an option for hybrid architecture while the evolutionary journey continues to the cloud.
Figure 10-9. Cloud migration to conference system using multicluster service mesh
Throughout the case study, our focus has been on highlighting key decision points that you and your team will have to make as a typical system evolves toward becoming API- or service-based. From the humble beginnings of a single service and database running on premises, as you have journeyed toward a multiservice system running across the cloud and on-premises, you have learned that with the increased flexibility this final implementation offers, there are also trade-offs with architecture and infrastructure complexity. Although this concludes the evolution of our case study in this book, we encourage you to experiment with creating new requirements, designing new APIs, and extracting additional services.
APIs, Conway’s Law, and Your Organization This is not a book about organizational design, but we wanted to mention the importance of this in relation to designing, building, and running APIs. “Conway’s Law” has become famous within the microservice community, and the concept also applies to API architecture: Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure. Melvin Conway in How Do Committees Invent?Or, put more succinctly, “if you have four groups working on a compiler, you’ll get a 4-pass compiler.” We have definitely seen this in the API world—as we like to joke, “if you have four groups working on a microservice system, you’ll get four layers of APIs.” We couldn’t hope to cover the topic of organizational design in the depth it deserves in this book, and so instead we would like to recommend you read the following books: Team Topologies (IT Revolution Press)Agile IT Organization Design: For Digital Transformation and Continuous Delivery (Addison-Wesley)The Art of Scalability (Addison-Wesley)
If you are looking to undertake a major organizational shift or “digital transformation,” we strongly recommend consulting the preceding works. Any API-based system is inherently a socio-technical system, and so you should always factor in the “socio” aspect as much as the “technical.”
Understanding Decision Types Jeff Bezos, the founder of Amazon, is famous for many things, and one of them is his discussion of Type 1 decisions and Type 2 decisions. Type 1 decisions are not easily reversible, and you have to be very careful making them. Type 2 decisions are easy to change: “like walking through a door—if you don’t like the decision, you can always go back.” Usually this concept is presented in relation to confusing the two, and using Type 1 processes on Type 2 decisions: “The end result of this is slowness, unthoughtful risk aversion, failure to experiment sufficiently, and consequently diminished invention. We’ll have to figure out how to fight that tendency.” However, in the majority of cases—especially within a large enterprise context—choosing API-enabling technologies like an API gateway or service mesh is very much a Type 1 decision. Ensure your organization acts accordingly!
Preparing for the Future When writing a book, we naturally capture experience and knowledge at a fixed point in time. There are always new developments emerging. Following are three topics that we didn’t believe yet warranted full sections but are nonetheless worth keeping an eye on for their future impact on API architecture.
Async Communication Asynchronous APIs are very popular, falling generally into two categories: client-server and client-broker. An example client-server relationship is achieved with technologies such as gRPC, and the client-broker relationship is achieved using intermediate technologies such as Kafka. As you learned about in Chapter 1, OpenAPI Specifications have been critical to consistently describing and specifying REST APIs. The AsyncAPI is an exciting and developing standard to provide a specification for asynchronous APIs. One challenge with asynchronous-based APIs is supporting the variety of protocol formats and range of technologies. It is definitely one to watch as the popularity of event-driven architectures and the need to define exchanges is a rapidly growing space.
HTTP/3 HTTP/3 is the third major version of the Hypertext Transfer Protocol used to exchange information on the World Wide Web, alongside HTTP/1.1 and HTTP/2. HTTP semantics are consistent across versions: the same request methods, status codes, and message fields are typically applicable to all versions. The differences are in the mapping of these semantics to underlying transport protocols. Both HTTP/1.1 and HTTP/2 use TCP as their transport (as in TCP/IP). HTTP/3 uses QUIC, a transport layer network protocol that uses UDP. The switch to QUIC aims to fix a major problem of HTTP/2 called “head-of-line blocking,” which in particular affects websites that require multiple resources to load. HTTP/3 promised potentially big speed gains, but as the underlying transport protocol has changed, this will require upgrades to ingress proxies and other networking components. The good news is that as of the time of writing, HTTP/3 is already supported by more than 70% of running web browsers.
Platform-based Mesh As hinted within Chapter 4, many signals are pointing toward service mesh being merged with modern platform offerings. If this trend continues, it may be wise to adopt the mesh integrated within your chosen vendor’s technology stack. In much the same way that the majority of organizations adopting a cloud vendor’s Kubernetes stack don’t replace the container (OCI) or networking (CNI) implementations, it may well be the same in the future with the service-to-service communications. As part of this evolution, we recommend keeping watch on related standards in this space, such as the Service Mesh Interface (SMI). The emergence and adoption of solid interfaces surely point toward this layer of the communication stack being homogenized.
What’s Next: How to Keep Learning About API Architecture We began this book by mentioning that all three of us started the journey that ultimately led to the creation of this book in February 2020 at the O’Reilly Software Architecture Conference (SACON). We all love learning, and attending events is a big part of our continued approach to gaining new skills and knowledge. One of the most common general questions we get asked relates to how we approach learning and experimenting with new technologies. In this section of the chapter, we’ll share with you our practices, insights, and habits.
Continually Honing the Fundamentals We all believe that it is vitally importantly to constantly revisit the fundamentals of any skill you wish to master. This is especially important in such a fad-driven industry like the software development and operations domains. We’ll cover some of the locations of where we search out this kind of knowledge, but we want to stress that when browsing websites, reading books, attending conferences, and the like, we actively seek out the existing and latest coverage of the fundamentals. For example, at many architecture conferences you will find sessions covering topics such as cohesion and coupling, and we have all at times learned and been reminded of concepts that we take back to our offices and apply the next day. As well as reading the latest book on cloud platforms, we also read new takes on traditional topics, such as Gregor Hohpe’s “The Architect Elevator: The Transformation Architect.” It’s very much a cliche in our industry that “what’s old is new,” and the cycles of technology that constantly repeat in slightly different forms can be navigated much more effectively by architecture designers who are constantly reminding themselves of the fundamentals.
Keeping Up-to-Date with Industry News We recommend collating and constantly refining a list of websites and social media sites that provide coverage of the latest news within the architecture and API domains. Reading these once a week will help tune your sense of emerging trends and technologies that you may want to investigate. For example: InfoQDZoneThe New StackSoftware Architecture Reddit
In addition to these general news sites and aggregators, you will also likely find certain organizations or individuals that write useful blogs on emerging topics. Using an RSS reader, such as Feedly, can allow you to collate these sources and review them on a weekly or monthly basis. Twitter can be a powerful tool for insights and comments on emerging technologies; following individuals who have similar interests and contribute to open source projects is a good way to find out early about new features.
Radars, Quadrants, and Trend Reports Although you should always perform your own experiments and proof of concept work, we also recommend keeping up-to-date with specific technology trends via analyst sites. This type of content can be especially useful when you are struggling with a problem or have identified a solution and are in need of a specific piece of technology that many vendors offer. We recommend the following sources of information for learning more about the state of the art of technology within the API space: ThoughtWorks Technology RadarGartner Magic Quadrant for Full Life Cycle API ManagementCloud Native Computing Foundation (CNCF) Tech RadarInfoQ Trends Reports
Several organizations and individuals also publish periodic technology comparison spreadsheets, and these can be useful for simple “paper evaluations” in order to shortlist products to experiment with. It should go without saying that you will need to check for bias across these comparisons (vendors frequently sponsor such work) and ensure the publication date is relatively recent.
Learning About Best Practices and Use Cases We also recommend that you constantly be on the lookout for best practices and use cases related to the work you are doing. Many organizations like to share the why, what, and how of what they are doing. The motivations for this are important to understand, but often it’s a mix of altruism, bragging rights, sales awareness, and recruiting. You always have to apply caution when learning about use cases, as most of these do skew toward positive coverage, potentially skipping over the initial failed tries, things that went wrong, or things that are still going wrong. However, the context provided can enable you to pattern match problems and solutions onto your organization and team. Sometimes this can provide confirmation of your chosen technology stack or approach, and on other occasions this can cause you to rethink! Use cases and best practices can often be found in written and presentation format. Generally we recommend looking for both, and the advantage of conference presentations is that you can chat with the presenters after the talk in order to learn more! Following is a list of conferences that we regularly attend: QCon conference seriesCraftConfAPIDays (API-focused)KubeCon (platform-specific)Devoxx / JavaOne (language-specific)O’Reilly online events
Learning by Doing We believe that architects should remain as practicing software engineers. You may not be pushing code to production each day, but we recommend carving out time in your schedule to periodically pair with an engineer on your team or conduct research and experiment with the latest technologies. Without doing this regularly, it is easy for an architect’s empathy for developers to fade. Doing this work also enables you to understand new friction points or a toil that may have been introduced by the adoption of new technologies. For example, anecdotally we found that many architects initially misunderstood the impact that container technology would have on developer toolchains. Unless you have experience in building container images and pushing them to a remote registry, it’s easy to discount the impact of these actions on your daily workflow of building and maintaining APIs.
Learning by Teaching As is hopefully evident from this book, we also learn a lot through the act of teaching. Whether this is writing books, teaching courses, or presenting at conferences, nothing beats the experience of assembling the information required to teach a concept. All too often we realize during this process that we don’t quite understand a concept, or when asked a question by a student we suddenly appreciate that there is a gap in our understanding. It is our opinion that another core role of an architect is teaching. Whether it’s educating developers about the fundamentals or sharing new best practices, this act of teaching will continually reinforce your skill set and establish your credibility within the larger team. Best of luck on your journey to mastering API architecture.
Index A abstract protocol for OAuth2 grants, Terminology and Mechanisms of OAuth2 Grants abstractions, high cohesion and, Creating Useful Abstractions: Increasing Cohesion-Creating Useful Abstractions: Increasing Cohesion account management with API gateways, Monetize APIs: Account Management, Billing, and Payment adapter architectural pattern, Facade and Adapter ADCs (application delivery controllers), Mid-2000s: Application Delivery Controllers (ADCs) ADR Guidelineschoosing API standards, ADR Guideline: Choosing an API Standard choosing ingress traffic management solution, Guideline: Proxy, Load Balancer, or API Gateway contract testing, ADR Guideline: Contract Testing-ADR Guideline: Contract Testing end-to-end testing, ADR Guideline: End-to-End Testing-ADR Guideline: End-to-End Testing format for, Mastering API: ADR Guidelines integration testing, ADR Guideline: Integration Testing modeling exchanges, Guideline: Modeling Exchanges OAuth2, ADR Guideline: Should I Consider Using OAuth2? OAuth2 grants, ADR Guideline: Choosing Which OAuth2 Grants to Support opinionated platforms, ADR Guideline: Opinionated Platforms-ADR Guideline: Opinionated Platforms selecting API gateways, ADR Guideline: Selecting an API Gateway selecting service mesh, Checklist: Selecting a Service Mesh-Checklist: Selecting a Service Mesh separating release and deployment, ADR Guideline: Separating Release from Deployment with Traffic Management and Feature Flags service mesh versus libraries, Guideline: Should You Adopt Service Mesh? Session service extraction, Case Study: Extracting Sessions Functionality to a Service testing strategies, ADR Guideline for Testing Strategies
ADRs (architecture decision records)in conference system case study, Attendees Evolution ADR-Attendees Evolution ADR defined, Using Architecture Decision Records-Using Architecture Decision Records for irreversible decisions, Using Fitness Functions sections of, Using Architecture Decision Records
aggregating backend services, Simplify Consumption: Aggregating/Translating Backend Services-Simplify Consumption: Aggregating/Translating Backend Services alerts, tying to metrics, Important Metrics for APIs Ambassador Edge Stack, installing, Installing Ambassador Edge Stack in Kubernetes analyst sites, Radars, Quadrants, and Trend Reports API gatewaysadding to conference system case study, Case Study: Exposing the Attendee Service to Consumers, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey benefits of, Why Use an API Gateway?-Monetize APIs: Account Management, Billing, and Paymentbackend aggregation/translation, Simplify Consumption: Aggregating/Translating Backend Services-Simplify Consumption: Aggregating/Translating Backend Services lifecycle management, Manage APIs as Products: API Lifecycle Management-Manage APIs as Products: API Lifecycle Management loose coupling, Reduce Coupling: Adapter/Facade Between Frontends and Backends monetization, Monetize APIs: Account Management, Billing, and Payment observability, Understand How APIs Are Being Consumed: Observability-Understand How APIs Are Being Consumed: Observability threat detection/mitigation, Protect APIs from Overuse and Abuse: Threat Detection and Mitigation-Protect APIs from Overuse and Abuse: Threat Detection and Mitigation
configuring Mappings, Configuring Mappings from URL Paths to Backend Services-Configuring Mappings Using Host-based Routing defined, What Is an API Gateway? deployment location, Where Is an API Gateway Deployed?-Where Is an API Gateway Deployed? edge proxies and ingress controllers versus, 2015 Onward: Second-Generation API Gateways failure management, Deploying API Gateways: Understanding and Managing Failure-Mitigating Risks history of, A Modern History of API Gateways-2015 Onward: Second-Generation API Gateways implementation pitfalls, Common API Gateway Implementation Pitfalls-Turtles (API Gateways) All the Way Down input validation, Payload injection-Payload injection installing, Installing Ambassador Edge Stack in Kubernetes integration with edge technologies, How Does an API Gateway Integrate with Other Technologies at the Edge?-How Does an API Gateway Integrate with Other Technologies at the Edge? purpose of, What Functionality Does an API Gateway Provide? rate limiting, Rate limiting and load shedding reverse proxies and load balancers versus, Is an API Gateway the Only Solution?-Guideline: Proxy, Load Balancer, or API Gateway security misconfiguration, Security misconfiguration-Security directive hardening selecting, Selecting an API Gateway-ADR Guideline: Selecting an API Gateway service mesh as, Service Mesh as Gateway types of, Current API Gateway Taxonomy-Comparing API Gateway Types
API keysauthentication with, System-to-System Authentication mixing authentication types, Why You Shouldn’t Mix Keys and Users
API layer cake architectural pattern, API Layer Cake API management in cloud migration, Role of API Management-Role of API Management API-First design, The Architecture Journey, Role of API Management APIs (application programming interfaces)asynchronous, Async Communication in conference system case study, Types of APIs in the Conference Case Study Conway's Law, APIs, Conway’s Law, and Your Organization-APIs, Conway’s Law, and Your Organization defined, A Brief Introduction to APIs-A Brief Introduction to APIs designing, Case Study: Designing the Attendee API-Case Study: Designing the Attendee APIMicrosoft REST API Guidelines, REST API Standards and Structure
evolving systems witharchitectural patterns, Architectural Patterns for Evolving Systems with APIs-API Layer Cake benefits of, Why Use APIs to Evolve a System?-Case Study: Establishing Attendee Domain Boundaries change leverage points, Identifying Change Leverage Points within a System end state architectures, End State Architecture Options-Functions fitness functions, Using Fitness Functions-Using Fitness Functions goal setting, Determine Your Goals-Determine Your Goals module design, Decomposing a System into Modules-Decomposing a System into Modules pain points and opportunities, Identifying Pain Points and Opportunities-Breaking Dependencies: Highly Coupled APIs process management, Managing the Evolutionary Process-Continuous Delivery and Verification seams for extension, Creating APIs as “Seams” for Extension-Creating APIs as “Seams” for Extension
modeling, From Tiered Architecture to Modeling APIs multiformat APIs, Multiple Specifications-Challenges of Combined Specifications REST (see REST) testing (see testing APIs) versioningOAS and, OpenAPI Specification and Versioning-OpenAPI Specification and Versioning options for, API Versioning-API Versioning semantic versioning, Semantic Versioning
application delivery controllers (ADCs), Mid-2000s: Application Delivery Controllers (ADCs) application programming interfaces (see APIs) application-level decisions for release, Application Decisions for Effective Software Releases-ADR Guideline: Opinionated Platforms applications (see systems) architectural patterns, Architectural Patterns for Evolving Systems with APIs-API Layer Cake architecture decision records (see ADRs) Argo Rollouts, Case Study: Performing Rollouts with Argo Rollouts-Case Study: Performing Rollouts with Argo Rollouts assets management, improper, Improper assets management asynchronous APIs, Async Communication Attendee API (see conference system case study) authenticationAttendee API, Authentication, Case Study: A Look Back on Your Journey defined, Authentication MFA (Multi-Factor Authentication), Authentication system-to-system, System-to-System Authentication token-based, End-User Authentication with Tokens-End-User Authentication with Tokens
authorizationelevation of privilege, Elevation of Privilege OAuth2abstract protocol, Terminology and Mechanisms of OAuth2 Grants Authorization Code Grant, Authorization Code Grant-Case Study: Accessing Attendee API with the Authorization Code Grant Client Credentials Grant, Client Credentials Grant-Case Study: Accessing Attendee API from the CFP system with Client Credentials Grant defined, OAuth2 Device Authorization Grant, Additional OAuth2 Grants enforcement, Authorization Enforcement-Authorization Enforcement grant guidelines, ADR Guideline: Choosing Which OAuth2 Grants to Support guidelines, ADR Guideline: Should I Consider Using OAuth2? Implicit Grant, Additional OAuth2 Grants JWT (JSON Web Token), JSON Web Tokens (JWT)-Encoding and verifying JSON Web Tokens refresh tokens, Refresh Tokens Resource Owner Password Credentials Grant, Additional OAuth2 Grants roles in, OAuth2-Authorization Server Role with API Interactions scopes, OAuth2 Scopes-Case Study: Applying OAuth2 scopes to the Attendee API
OIDC (OpenID Connect), Introducing OIDC-Introducing OIDC SAML 2.0 (Security Assertion Markup Language), SAML 2.0
Authorization Code Grant (OAuth2), Authorization Code Grant-Case Study: Accessing Attendee API with the Authorization Code Grant authorization servers, OAuth2 automating end-to-end testing, Automating End-to-End Validation-Automating End-to-End Validation
B best practices, Learning About Best Practices and Use Cases-Learning About Best Practices and Use Cases billing with API gateways, Monetize APIs: Account Management, Billing, and Payment blue-green, Blue-Green-Blue-Green BOLA (Broken Object Level Authorization), Authorization Enforcement Broken Function Level Authorization, Authorization Enforcement
C C4 diagramscomponent, C4 Component Diagram container, C4 Container Diagram context, C4 Context Diagram UML versus, Using C4 Diagrams
canary releases, Canary Releases-Canary Releases case study (see conference system case study) CDCs (consumer-driven contracts), Consumer-driven contracts CDNs (content delivery networks), Early 2000s Onward: Software Load Balancers change detection with OAS, Detecting Changes change leverage points, Identifying Change Leverage Points within a System Cilium, Sidecarless: Operating system kernel (eBPF) implementations circular dependencies, Denial of service Client Credentials Grant (OAuth2), Client Credentials Grant-Case Study: Accessing Attendee API from the CFP system with Client Credentials Grant clients, OAuth2 cloud migrationAPI management in, Role of API Management-Role of API Management Attendee API, Case Study: Moving the Attendee Service to the Cloud, Case Study: Replatforming the Attendee Service to the Cloud-Case Study: Replatforming the Attendee Service to the Cloud, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey strategies for, Choosing a Cloud Migration Strategy-Retirerefactor, Refactor/Re-architect-Refactor/Re-architect rehost, Rehost-Rehost replatform, Replatform repurchase, Repurchase retain or revisit, Retain or Revisit-Retain or Revisit retire, Retire
traffic management in, North–South Versus East–West: Blurring Lines of Traffic Management-Crossing Boundaries: Routing Across Networks
cohesion, Creating Useful Abstractions: Increasing Cohesion-Creating Useful Abstractions: Increasing Cohesion collectionsfiltering, Filtering Collections-Filtering Collections pagination, Collections and Pagination
Common Vulnerability Scoring System (CVSS), Step 5: Evaluate Threat Risks component diagrams, C4 Component Diagram component testing, API Component Testing-Case Study: Component Test to Verify Behavior concurrent API calls, orchestrating, Simplify Consumption: Aggregating/Translating Backend Services conference system case studyAPI gateway addition, Case Study: Exposing the Attendee Service to Consumers, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey API types in, Types of APIs in the Conference Case Study Attendee service extraction, Case Study: An Evolutionary Step-East–west traffic, Case Study: A Look Back on Your Journey attendees evolution ADR, Attendees Evolution ADR-Attendees Evolution ADR authentication, Authentication, Case Study: A Look Back on Your Journey authorizationAuthorization Code Grant, Case Study: Accessing Attendee API with the Authorization Code Grant Client Credentials Grant, Case Study: Accessing Attendee API from the CFP system with Client Credentials Grant OAuth2 roles, Authorization Server Role with API Interactions scopes, Case Study: Applying OAuth2 scopes to the Attendee API-Case Study: Applying OAuth2 scopes to the Attendee API
CDCs (consumer-driven contracts), Case study: Applying CDC change requirements for, Reasons for Changing the Conference System cloud migration, Case Study: Moving the Attendee Service to the Cloud, Case Study: Replatforming the Attendee Service to the Cloud-Case Study: Replatforming the Attendee Service to the Cloud, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey components of, Running Example: Conference System Case Study-Running Example: Conference System Case Study, Case Study: A Look Back on Your Journey designing APIs, Case Study: Designing the Attendee API-Case Study: Designing the Attendee APIMicrosoft REST API Guidelines, REST API Standards and Structure
exposing APIs, Case Study: Exposing the Attendee Service to Consumers, Case Study: Evolving the Conference System Using an API Gateway-Configuring Mappings Using Host-based Routing, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey feature flags, Case Study: Feature Flagging-Case Study: Feature Flagging, Case Study: A Look Back on Your Journey loose coupling, Case Study: Establishing Attendee Domain Boundaries modeling APIs in, From Tiered Architecture to Modeling APIs module design, Decomposing a System into Modules multicluster service mesh, Augmenting Service Mesh with Network Policies, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey release with Argo Rollouts, Case Study: Performing Rollouts with Argo Rollouts-Case Study: Performing Rollouts with Argo Rollouts roadmap for, Roadmap for the Conference Case Study-Roadmap for the Conference Case Study Session service extraction, Case Study: Extracting Sessions Functionality to a Service-Case Study: Extracting Sessions Functionality to a Service, Case Study: A Look Back on Your Journey testing APIs, Conference System Scenario for This Chaptercomponent testing, Case Study: Component Test to Verify Behavior-Case Study: Component Test to Verify Behavior integration testing, Case Study: Applying Testcontainers to Verify Integrations-Case Study: Applying Testcontainers to Verify Integrations
threat modeling, Case Study: Applying OWASP to the Attendee API-Case Study: Applying OWASP to the Attendee API, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journeyinput validation, Payload injection-Payload injection mass assignment, Mass assignment-Mass assignment rate limiting, Rate limiting and load shedding
traffic patterns in, Case Study: An Evolutionary Step-East–west traffic, Case Study: A Look Back on Your Journey
configuring Mappings, Configuring Mappings from URL Paths to Backend Services-Configuring Mappings Using Host-based Routing Consul, Network Segmentation with Consul-Network Segmentation with Consul consumer-driven contracts (CDCs), Consumer-driven contracts consumersattendee API design, Case Study: Designing the Attendee API-Case Study: Designing the Attendee API defined, Contract Testing
container diagrams, C4 Container Diagram containers, C4 Container Diagram content delivery networks (CDNs), Early 2000s Onward: Software Load Balancers context diagrams, C4 Context Diagram continuous learning, What’s Next: How to Keep Learning About API Architecture-Learning by Teaching contract testingbenefits of, Why Contract Testing Is Often Preferable-Why Contract Testing Is Often Preferable contract implementation, How a Contract Is Implemented-API contracts storage and publishing frameworks for, Contract testing frameworks guidelines, ADR Guideline: Contract Testing-ADR Guideline: Contract Testing terminology, Contract Testing
contractsconsumer-driven, Consumer-driven contracts creating, How a Contract Is Implemented-How a Contract Is Implemented defined, Contract Testing methodology overview, Contracts methodology overview producer contracts, Producer contracts-Producer contracts storing and publishing, API contracts storage and publishing
control plane, What Is an API Gateway? converting between API specifications, Multiple Specifications-Challenges of Combined Specifications Conway's Law, APIs, Conway’s Law, and Your Organization-APIs, Conway’s Law, and Your Organization CORS (cross-origin request sharing), Cross-Origin Request Sharing (CORS) CRDs (Custom Resource Definitions), Case Study: Performing Rollouts with Argo Rollouts cross-functional communication with service mesh, Supporting Cross-Functional Communication Across Languages cross-functional goals for evolving systems, Determine Your Goals CVSS (Common Vulnerability Scoring System), Step 5: Evaluate Threat Risks
D data flow diagrams (DFDs), Threat Modeling 101-Threat Modeling 101, Step 3: Decompose the System data plane, What Is an API Gateway? decision types, Understanding Decision Types decoupling (see separating release and deployment) denial of service (DoS), Denial of service-Rate limiting and load shedding dependencies, breaking, Breaking Dependencies: Highly Coupled APIs deploymentdefined, Separating Deployment and Release separating from release, Separating Deployment and Release-ADR Guideline: Separating Release from Deployment with Traffic Management and Feature Flagsfeature flags, Case Study: Feature Flagging-Case Study: Feature Flagging guidelines, ADR Guideline: Separating Release from Deployment with Traffic Management and Feature Flags lifecycle management, Case Study: Modeling Releases in the Conference System-Mapping Release Strategies to Lifecycle traffic management, Traffic Management-Traffic Management
deprecation warnings, Retain or Revisit designing APIs, Case Study: Designing the Attendee API-Case Study: Designing the Attendee APIMicrosoft REST API Guidelines, REST API Standards and Structure
detecting changes with OAS, Detecting Changes Device Authorization Grant (OAuth2), Additional OAuth2 Grants DFDs (data flow diagrams), Threat Modeling 101-Threat Modeling 101, Step 3: Decompose the System diagnostics, Logging to Assist Debugging doing, learning by, Learning by Doing DoS (denial of service), Denial of service-Rate limiting and load shedding DREAD methodology, Step 5: Evaluate Threat Risks-Step 5: Evaluate Threat Risks DREAD-D methodology, Step 5: Evaluate Threat Risks
E east–west trafficin cloud migration, North–South Versus East–West: Blurring Lines of Traffic Management-Crossing Boundaries: Routing Across Networks defined, East–west traffic gRPC server implementation, Implementing RPC with gRPC-Implementing RPC with gRPC modeling exchanges, Modeling Exchanges and Choosing an API Formatguidelines for, Guideline: Modeling Exchanges high-traffic services, High-Traffic Services HTTP/2 performance, HTTP/2 Performance Benefits large payloads, Large Exchange Payloads-Large Exchange Payloads vintage components, Vintage Formats
separating from north–south traffic management, Separating Ingress and Service-to-Service Traffic Management-Separating Ingress and Service-to-Service Traffic Management service meshbenefits of, Why Use a Service Mesh?-Separating Ingress and Service-to-Service Traffic Management defined, What Is Service Mesh?-What Is Service Mesh? deployment location, Where Is a Service Mesh Deployed? failure management, Deploying a Service Mesh: Understanding and Managing Failure history of, Evolution of Service Mesh-Early History and Motivations implementation patterns, Implementation Patterns-Service Mesh Taxonomy implementation pitfalls, Common Service Mesh Implementation Challenges-Too Many Networking Layers integration with networking technologies, How Does a Service Mesh Integrate with Other Networking Technologies?-How Does a Service Mesh Integrate with Other Networking Technologies? libraries versus, Is Service Mesh the Only Solution?-Guideline: Should You Adopt Service Mesh? network segmentation with Consul, Network Segmentation with Consul-Network Segmentation with Consul observing with Linkerd, Observing Traffic with Linkerd-Observing Traffic with Linkerd purpose of, What Functionality Does a Service Mesh Provide?-What Functionality Does a Service Mesh Provide? routing with Istio, Routing with Istio-Routing with Istio selecting, Selecting a Service Mesh-Checklist: Selecting a Service Mesh
eBPF service mesh implementation, Sidecarless: Operating system kernel (eBPF) implementations edge proxies, 2015 Onward: Second-Generation API Gateways elevation of privilege, Elevation of Privilege end state architectures, End State Architecture Options-Functions end-to-end testingautomating, Automating End-to-End Validation-Automating End-to-End Validation defined, Test Pyramid guidelines, ADR Guideline: End-to-End Testing-ADR Guideline: End-to-End Testing purpose of, End-to-End Testing types of tests, Types of End-to-End Tests-Types of End-to-End Tests
end-user authentication, End-User Authentication with Tokens-End-User Authentication with Tokensmixing with key-based, Why You Shouldn’t Mix Keys and Users
enforcement of authorization, Authorization Enforcement-Authorization Enforcement error handling, guidelines for, Error Handling ESB (enterprise service bus)API gateway as, API Gateway as an ESB service mesh as, Service Mesh as ESB
evaluating risks, Step 5: Evaluate Threat Risks-Step 5: Evaluate Threat Risks evolutionary architecture, The Architecture Journey evolving systemswith APIsarchitectural patterns, Architectural Patterns for Evolving Systems with APIs-API Layer Cake benefits of, Why Use APIs to Evolve a System?-Case Study: Establishing Attendee Domain Boundaries change leverage points, Identifying Change Leverage Points within a System end state architectures, End State Architecture Options-Functions fitness functions, Using Fitness Functions-Using Fitness Functions goal setting, Determine Your Goals-Determine Your Goals module design, Decomposing a System into Modules-Decomposing a System into Modules pain points and opportunities, Identifying Pain Points and Opportunities-Breaking Dependencies: Highly Coupled APIs process management, Managing the Evolutionary Process-Continuous Delivery and Verification seams for extension, Creating APIs as “Seams” for Extension-Creating APIs as “Seams” for Extension
to cloud migrationAPI management in, Role of API Management-Role of API Management for Attendee API, Case Study: Moving the Attendee Service to the Cloud, Case Study: Replatforming the Attendee Service to the Cloud-Case Study: Replatforming the Attendee Service to the Cloud, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey strategies for, Choosing a Cloud Migration Strategy-Retire traffic management in, North–South Versus East–West: Blurring Lines of Traffic Management-Crossing Boundaries: Routing Across Networks
examples, OAS for, Examples and Mocking-Examples and Mocking excessive data exposure, Excessive data exposure-Excessive data exposure extractingAttendee service, Case Study: An Evolutionary Step-East–west traffic, Case Study: A Look Back on Your Journey Session service, Case Study: Extracting Sessions Functionality to a Service-Case Study: Extracting Sessions Functionality to a Service, Case Study: A Look Back on Your Journey
F facade architectural pattern, Facade and Adapter fail close policies, Rate limiting and load shedding fail open policies, Rate limiting and load shedding failure managementAPI gateways, Deploying API Gateways: Understanding and Managing Failure-Mitigating Risks metrics to track, Important Metrics for APIs-Important Metrics for APIs pillars of observability, Three Pillars of Observability-Three Pillars of Observability reading signals, Reading the Signals-Reading the Signals service mesh, Deploying a Service Mesh: Understanding and Managing Failure
feature flags, Case Study: Feature Flagging-Case Study: Feature Flagging, Case Study: A Look Back on Your Journey filtering collections, Filtering Collections-Filtering Collections first-generation API gateways, Early 2010s: First-Generation API Gateways fitness functions, Using Fitness Functions-Using Fitness Functions forward proxies, What Functionality Does an API Gateway Provide? friendly fire DoS (denial of service), Denial of service front controller pattern, Running Example: Conference System Case Study full proxies, What Functionality Does a Service Mesh Provide? functional goals for evolving systems, Determine Your Goals functions, Functions
G gateways (see API gateways) GDPR (General Data Protection Regulation), The Risk of Not Securing External APIs goals for evolving systems, Determine Your Goals-Determine Your Goals golden path (see opinionated platforms) grants (OAuth2)abstract protocol for, Terminology and Mechanisms of OAuth2 Grants Authorization Code Grant, Authorization Code Grant-Case Study: Accessing Attendee API with the Authorization Code Grant Client Credentials Grant, Client Credentials Grant-Case Study: Accessing Attendee API from the CFP system with Client Credentials Grant Device Authorization Grant, Additional OAuth2 Grants guidelines, ADR Guideline: Choosing Which OAuth2 Grants to Support Implicit Grant, Additional OAuth2 Grants refresh tokens, Refresh Tokens Resource Owner Password Credentials Grant, Additional OAuth2 Grants
GraphQL, A Brief Mention of GraphQL-A Brief Mention of GraphQL Gregory, Janet, Test Quadrant gRPC, Introduction to Remote Procedure Call (RPC) APIsconversion to/from OpenAPI, Multiple Specifications-Challenges of Combined Specifications libraries, Proxyless gRPC libraries-Proxyless gRPC libraries server implementation, Implementing RPC with gRPC-Implementing RPC with gRPC
grpc-gateway, Does the Golden Specification Exist?
H hardware load balancers, 1990s Onward: Hardware Load Balancers header propagation, Application-Level Header Propagation high cohesion, Reduce Coupling: Adapter/Facade Between Frontends and Backends, Creating Useful Abstractions: Increasing Cohesion-Creating Useful Abstractions: Increasing Cohesion high-traffic services, High-Traffic Services historyof API gateways, A Modern History of API Gateways-2015 Onward: Second-Generation API Gateways of service mesh, Evolution of Service Mesh-Early History and Motivations
host-based routing, Configuring Mappings Using Host-based Routing HTTP Basic, End-User Authentication with Tokens HTTP header allowlist, Security directive hardening HTTP/2 performance, HTTP/2 Performance Benefits HTTP/3, HTTP/2 Performance Benefits, HTTP/3
I Implicit Grant (OAuth2), Additional OAuth2 Grants improper assets management, Improper assets management in-process APIsin conference system case study, Types of APIs in the Conference Case Study defined, A Brief Introduction to APIs
incident response, Resolving Incidents and Issues industry news sites, Keeping Up-to-Date with Industry News-Keeping Up-to-Date with Industry News information disclosure, Information disclosure-Improper assets management information gathering in threat modeling, Step 2: Gather the Right Information information hiding, Reduce Coupling: Adapter/Facade Between Frontends and Backends, Case Study: Establishing Attendee Domain Boundaries infrastructure, traffic patterns and, API Infrastructure and Traffic Patterns ingress controllers, 2015 Onward: Second-Generation API Gateways ingress traffic management (see API gateways; north–south traffic) input validation with API gateways, Payload injection-Payload injection installing API gateways, Installing Ambassador Edge Stack in Kubernetes integration testing, API Integration Testingguidelines, ADR Guideline: Integration Testing stub servers in, Using Stub Servers: Why and How-Using Stub Servers: Why and How Testcontainers library, Containerizing Test Components: Testcontainers-Case Study: Applying Testcontainers to Verify Integrations
intentions (Consul), Network Segmentation with Consul-Network Segmentation with Consul irreversible decisions, Using Fitness Functions Istio, Routing with Istio-Routing with Istio
J journaling, Logging to Assist Debugging JWE (JSON Web Encryption), Encoding and verifying JSON Web Tokens JWS (JSON Web Signature), Encoding and verifying JSON Web Tokens JWT (JSON Web Token), JSON Web Tokens (JWT)-Encoding and verifying JSON Web Tokens
K keys, authentication with, System-to-System Authentication Kubernetes, installing Ambassador Edge Stack, Installing Ambassador Edge Stack in Kubernetes
L large exchange payloads, Large Exchange Payloads-Large Exchange Payloads learningcontinuous, What’s Next: How to Keep Learning About API Architecture-Learning by Teaching by doing, Learning by Doing by teaching, Learning by Teaching
leverage points for change, Identifying Change Leverage Points within a System librariesservice mesh implementation, Libraries-Libraries service mesh versus, Is Service Mesh the Only Solution?-Guideline: Should You Adopt Service Mesh?
lifecycle managementAPI gateways, Manage APIs as Products: API Lifecycle Management-Manage APIs as Products: API Lifecycle Management mapping release strategies, Mapping Release Strategies to Lifecycle steps in, API Lifecycle
Linkerd, Observing Traffic with Linkerd-Observing Traffic with Linkerd load balancers versus API gateways and reverse proxies, Is an API Gateway the Only Solution?-Guideline: Proxy, Load Balancer, or API Gateway load shedding, Rate limiting and load shedding logsdefined, Three Pillars of Observability types of, Logging to Assist Debugging
long-lived tokens, Encoding and verifying JSON Web Tokens loopback (API gateways), API Gateway Loopback loose coupling, Reduce Coupling: Adapter/Facade Between Frontends and Backends, Clarifying Domain Boundaries: Promoting Loose Coupling
M maintenance issues when evolving systems, Upgrade and Maintenance Issues major versions, Semantic Versioning Mappings, configuring, Configuring Mappings from URL Paths to Backend Services-Configuring Mappings Using Host-based Routing mass assignment, Mass assignment-Mass assignment mesh (see service mesh) mesh networking, What Is Service Mesh? metricsdefined, Three Pillars of Observability reading signals from, Reading the Signals-Reading the Signals which to track, Important Metrics for APIs-Important Metrics for APIs
MFA (Multi-Factor Authentication), Authentication microservices, Microservices/Micro Gateways, Microservices-Microservices Microsoft REST API Guidelines, REST API Standards and Structure-REST API Standards and Structurechoosing API standards, ADR Guideline: Choosing an API Standard error handling, Error Handling filtering collections, Filtering Collections-Filtering Collections naming, REST API Standards and Structure pagination, Collections and Pagination
Microsoft Threat Modeling Tool, Step 4: Identify Threats—Taking This in Your STRIDE migration (see cloud migration; evolving systems) minor versions, Semantic Versioning misconfiguration of security, Security misconfiguration-Security directive hardening mocking, OAS for, Examples and Mocking-Examples and Mocking modeling APIs, From Tiered Architecture to Modeling APIs modeling exchanges, Modeling Exchanges and Choosing an API Formatguidelines for, Guideline: Modeling Exchanges high-traffic services, High-Traffic Services HTTP/2 performance, HTTP/2 Performance Benefits large payloads, Large Exchange Payloads-Large Exchange Payloads vintage components, Vintage Formats
modules, decomposing systems into, Decomposing a System into Modules-Decomposing a System into Modules monetization of APIs, Monetize APIs: Account Management, Billing, and Payment monitoring in failure management, Detecting and Owning Problems monolithic architectures, Monolith-Monolith Multi-Factor Authentication (MFA), Authentication multicluster service mesh, Augmenting Service Mesh with Network Policies, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey multiformat APIs, Multiple Specifications-Challenges of Combined Specifications multiple API gateways, Turtles (API Gateways) All the Way Down
N naming APIs, REST API Standards and Structure network policies in zero trust architectures, Augmenting Service Mesh with Network Policies-Augmenting Service Mesh with Network Policies network segmentation with Consul, Network Segmentation with Consul-Network Segmentation with Consul north–south trafficAPI gatewaysbenefits of, Why Use an API Gateway?-Monetize APIs: Account Management, Billing, and Payment configuring Mappings, Configuring Mappings from URL Paths to Backend Services-Configuring Mappings Using Host-based Routing defined, What Is an API Gateway? deployment location, Where Is an API Gateway Deployed?-Where Is an API Gateway Deployed? edge proxies and ingress controllers versus, 2015 Onward: Second-Generation API Gateways failure management, Deploying API Gateways: Understanding and Managing Failure-Mitigating Risks history of, A Modern History of API Gateways-2015 Onward: Second-Generation API Gateways implementation pitfalls, Common API Gateway Implementation Pitfalls-Turtles (API Gateways) All the Way Down installing, Installing Ambassador Edge Stack in Kubernetes integration with edge technologies, How Does an API Gateway Integrate with Other Technologies at the Edge?-How Does an API Gateway Integrate with Other Technologies at the Edge? purpose of, What Functionality Does an API Gateway Provide? reverse proxies and load balancers versus, Is an API Gateway the Only Solution?-Guideline: Proxy, Load Balancer, or API Gateway selecting, Selecting an API Gateway-ADR Guideline: Selecting an API Gateway types of, Current API Gateway Taxonomy-Comparing API Gateway Types
in cloud migration, North–South Versus East–West: Blurring Lines of Traffic Management-Crossing Boundaries: Routing Across Networks defined, North–south traffic modeling exchanges, Modeling Exchanges and Choosing an API Formatguidelines for, Guideline: Modeling Exchanges high-traffic services, High-Traffic Services HTTP/2 performance, HTTP/2 Performance Benefits large payloads, Large Exchange Payloads-Large Exchange Payloads vintage components, Vintage Formats
separating from east–west traffic management, Separating Ingress and Service-to-Service Traffic Management-Separating Ingress and Service-to-Service Traffic Management
O OAS (OpenAPI Specifications)for change detection, Detecting Changes for code generation, Code Generation conversion to/from gRPC, Multiple Specifications-Challenges of Combined Specifications for examples and mocking, Examples and Mocking-Examples and Mocking explained, Specifying REST APIs Using OpenAPI-Specifying REST APIs Using OpenAPI for validation, OpenAPI Validation-OpenAPI Validation versioning and, OpenAPI Specification and Versioning-OpenAPI Specification and Versioning
OAuth2defined, OAuth2 enforcement, Authorization Enforcement-Authorization Enforcement grantsabstract protocol for, Terminology and Mechanisms of OAuth2 Grants Authorization Code Grant, Authorization Code Grant-Case Study: Accessing Attendee API with the Authorization Code Grant Client Credentials Grant, Client Credentials Grant-Case Study: Accessing Attendee API from the CFP system with Client Credentials Grant Device Authorization Grant, Additional OAuth2 Grants guidelines, ADR Guideline: Choosing Which OAuth2 Grants to Support Implicit Grant, Additional OAuth2 Grants refresh tokens, Refresh Tokens Resource Owner Password Credentials Grant, Additional OAuth2 Grants
guidelines, ADR Guideline: Should I Consider Using OAuth2? JWT (JSON Web Token), JSON Web Tokens (JWT)-Encoding and verifying JSON Web Tokens roles in, OAuth2-Authorization Server Role with API Interactions scopes, OAuth2 Scopes-Case Study: Applying OAuth2 scopes to the Attendee API
objectives, identifying for threat modeling, Step 1: Identify Your Objectives observability, Understand How APIs Are Being Consumed: Observability-Understand How APIs Are Being Consumed: Observabilityin failure management, Detecting and Owning Problems pillars of, Three Pillars of Observability-Three Pillars of Observability of service mesh, Provide Transparent Observability-Provide Transparent Observabilitywith Linkerd, Observing Traffic with Linkerd-Observing Traffic with Linkerd
OIDC (Open ID Connect), Introducing OIDC-Introducing OIDC OPA (Open Policy Agent), Network Segmentation with Consul OpenAPI Specifications (see OAS) openapi-diff, OpenAPI Specification and Versioning openapi2proto, Does the Golden Specification Exist? OpenTelemetry project, Three Pillars of Observability operating system kernel (eBPF) service mesh implementation, Sidecarless: Operating system kernel (eBPF) implementations Operations Zone (OZ), Getting in the Zone opinionated platforms, Considering an Opinionated Platform-ADR Guideline: Opinionated Platforms orchestrating concurrent API calls, Simplify Consumption: Aggregating/Translating Backend Services organizational design, APIs, Conway’s Law, and Your Organization-APIs, Conway’s Law, and Your Organization out-of-process APIsin conference system case study, Types of APIs in the Conference Case Study defined, A Brief Introduction to APIs
OWASP (Open Web Application Security Project), Case Study: Applying OWASP to the Attendee API
P Pact, Contract testing frameworks pagination of collections, Collections and Pagination patch versions, Semantic Versioning paved path (see opinionated platforms) payload injection, Payload injection-Payload injection payment with API gateways, Monetize APIs: Account Management, Billing, and Payment performance issues when evolving systems, Performance Issues performance testing, Types of End-to-End Tests perimeterless security (see zero trust architecture) PKCE (Proof Key for Code Exchange), Authorization Code Grant (+ PKCE)-Authorization Code Grant (+ PKCE) platform-based mesh, Platform-based Mesh plug-ins with API gateways, API Gateway as an ESB producer contracts, Producer contracts-Producer contracts producersattendee API design, Case Study: Designing the Attendee API-Case Study: Designing the Attendee API defined, Contract Testing
providers (see producers) proxy servers, What Functionality Does an API Gateway Provide? proxyless gRPC libraries, Proxyless gRPC libraries-Proxyless gRPC libraries Public Access Zone (PAZ), Getting in the Zone Public Zone (PZ), Getting in the Zone publishing contracts, API contracts storage and publishing
R rate limiting, Rate limiting and load shedding-Rate limiting and load shedding RBAC (Role Based Access Control), Authorization Enforcement RED (Rate, Error, Duration) metrics, Important Metrics for APIs-Important Metrics for APIs refactor cloud migration strategy, Refactor/Re-architect-Refactor/Re-architect refresh tokens, Refresh Tokens rehost cloud migration strategy, Rehost-Rehost releasesapplication-level decisions, Application Decisions for Effective Software Releases-ADR Guideline: Opinionated Platforms with Argo Rollouts, Case Study: Performing Rollouts with Argo Rollouts-Case Study: Performing Rollouts with Argo Rollouts defined, Separating Deployment and Release failure managementmetrics for, Important Metrics for APIs-Important Metrics for APIs pillars of observability, Three Pillars of Observability-Three Pillars of Observability reading signals, Reading the Signals-Reading the Signals
separating from deployment, Separating Deployment and Release-ADR Guideline: Separating Release from Deployment with Traffic Management and Feature Flagsfeature flags, Case Study: Feature Flagging-Case Study: Feature Flagging guidelines, ADR Guideline: Separating Release from Deployment with Traffic Management and Feature Flags lifecycle management, Case Study: Modeling Releases in the Conference System-Mapping Release Strategies to Lifecycle traffic management, Traffic Management-Traffic Management
strategiesblue-green, Blue-Green-Blue-Green canary releases, Canary Releases-Canary Releases mapping to lifecycle, Mapping Release Strategies to Lifecycle traffic mirroring, Traffic Mirroring-Traffic Mirroring
reliability of service mesh, Reliability-Reliability Remote Procedure Calls (see RPCs) replatform cloud migration strategy, Replatform repudiation, Repudiation-Repudiation repurchase cloud migration strategy, Repurchase Resource Owner Password Credentials Grant (OAuth2), Additional OAuth2 Grants resource owners, OAuth2 resource servers, OAuth2 resources for information, Keeping Up-to-Date with Industry News-Learning About Best Practices and Use Cases response caching, Response Caching REST (REpresentational State Transfer)defined, Introduction to REST example of, Introduction to REST and HTTP by Example-Introduction to REST and HTTP by Example Microsoft REST API Guidelines, REST API Standards and Structure-REST API Standards and Structurechoosing API standards, ADR Guideline: Choosing an API Standard error handling, Error Handling filtering collections, Filtering Collections-Filtering Collections naming, REST API Standards and Structure pagination, Collections and Pagination
OASfor change detection, Detecting Changes for code generation, Code Generation conversion to/from gRPC, Multiple Specifications-Challenges of Combined Specifications for examples and mocking, Examples and Mocking-Examples and Mocking explained, Specifying REST APIs Using OpenAPI-Specifying REST APIs Using OpenAPI for validation, OpenAPI Validation-OpenAPI Validation
Richardson maturity model, The Richardson Maturity Model-The Richardson Maturity Model RPCs versus, Introduction to Remote Procedure Call (RPC) APIs
Restricted Zone (RZ), Getting in the Zone retain or revisit cloud migration strategy, Retain or Revisit-Retain or Revisit retire cloud migration strategy, Retire reverse proxiesAPI gateways and load balancers versus, Is an API Gateway the Only Solution?-Guideline: Proxy, Load Balancer, or API Gateway defined, What Functionality Does an API Gateway Provide?
Richardson maturity model, The Richardson Maturity Model-The Richardson Maturity Model risk evaluation, Step 5: Evaluate Threat Risks-Step 5: Evaluate Threat Risks risk mitigation, Mitigating Risks risk of security breaches, The Risk of Not Securing External APIs-The Risk of Not Securing External APIs Role Based Access Control (RBAC), Authorization Enforcement routing control with service mesh, Fine-grained Control of Routing, Reliability, and Traffic Management-Transparent routing and service name normalizationIstio, Routing with Istio-Routing with Istio
RPCs (Remote Procedure Calls)conversion to/from OpenAPI, Multiple Specifications-Challenges of Combined Specifications defined, Introduction to Remote Procedure Call (RPC) APIs gRPC server implementation, Implementing RPC with gRPC-Implementing RPC with gRPC REST versus, Introduction to Remote Procedure Call (RPC) APIs
S SAML 2.0 (Security Assertion Markup Language), SAML 2.0 scenario testing, How a Contract Is Implemented, Types of End-to-End Tests schemas, Why Contract Testing Is Often Preferable scopes (OAuth2), OAuth2 Scopes-Case Study: Applying OAuth2 scopes to the Attendee API second-generation API gateways, 2015 Onward: Second-Generation API Gateways-2015 Onward: Second-Generation API Gateways securityauthentication (see authentication) authorization (see authorization) in end-to-end testing, Types of End-to-End Tests enforcement with service mesh, Enforce Security: Transport Security, Authentication, and Authorization risk of breaches, The Risk of Not Securing External APIs-The Risk of Not Securing External APIs single points of failure, API Gateway as a Single Point of Failure threat modeling (see threat modeling) zero trust architectureprinciples of, Trust No One and Verify-Trust No One and Verify service mesh in, Role of Service Mesh in Zero Trust Architectures-Augmenting Service Mesh with Network Policies
zonal architecture, Getting in the Zone-Getting in the Zone
security directive hardening, Security directive hardening security misconfiguration, Security misconfiguration-Security directive hardening selectingAPI gateways, Selecting an API Gateway-ADR Guideline: Selecting an API Gateway service mesh, Selecting a Service Mesh-Checklist: Selecting a Service Mesh
semantic versioning, Semantic Versioning separating release and deployment, Separating Deployment and Release-ADR Guideline: Separating Release from Deployment with Traffic Management and Feature Flagsfeature flags, Case Study: Feature Flagging-Case Study: Feature Flagging guidelines, ADR Guideline: Separating Release from Deployment with Traffic Management and Feature Flags lifecycle management, Case Study: Modeling Releases in the Conference System-Mapping Release Strategies to Lifecycle traffic management, Traffic Management-Traffic Management
service meshas API gateway, Service Mesh Gateways, Service Mesh as Gateway benefits of, Why Use a Service Mesh?-Separating Ingress and Service-to-Service Traffic Managementcross-functional communication, Supporting Cross-Functional Communication Across Languages observability, Provide Transparent Observability-Provide Transparent Observability reliability, Reliability-Reliability routing control, Fine-grained Control of Routing, Reliability, and Traffic Management-Transparent routing and service name normalization security enforcement, Enforce Security: Transport Security, Authentication, and Authorization separating ingress and service-to-service traffic management, Separating Ingress and Service-to-Service Traffic Management-Separating Ingress and Service-to-Service Traffic Management traffic policing, Traffic policing traffic shaping, Traffic shaping
defined, What Is Service Mesh?-What Is Service Mesh? deployment location, Where Is a Service Mesh Deployed? failure management, Deploying a Service Mesh: Understanding and Managing Failure history of, Evolution of Service Mesh-Early History and Motivations implementation patterns, Implementation Patterns-Service Mesh Taxonomycomparison of, Service Mesh Taxonomy eBPF, Sidecarless: Operating system kernel (eBPF) implementations libraries, Libraries-Libraries proxyless gRPC libraries, Proxyless gRPC libraries-Proxyless gRPC libraries sidecar proxies, Sidecars-Sidecars
implementation pitfalls, Common Service Mesh Implementation Challenges-Too Many Networking Layers integration with networking technologies, How Does a Service Mesh Integrate with Other Networking Technologies?-How Does a Service Mesh Integrate with Other Networking Technologies? libraries versus, Is Service Mesh the Only Solution?-Guideline: Should You Adopt Service Mesh? network segmentation with Consul, Network Segmentation with Consul-Network Segmentation with Consul observing with Linkerd, Observing Traffic with Linkerd-Observing Traffic with Linkerd platform-based, Platform-based Mesh purpose of, What Functionality Does a Service Mesh Provide?-What Functionality Does a Service Mesh Provide? routing with Istio, Routing with Istio-Routing with Istio selecting, Selecting a Service Mesh-Checklist: Selecting a Service Mesh in zero trust architectures, Role of Service Mesh in Zero Trust Architectures-Augmenting Service Mesh with Network Policies
service name normalization, Transparent routing and service name normalization service testing, Test Pyramid service-oriented architecture (SOA), Service-Oriented Architecture (SOA) service-to-service traffic management (see east–west traffic; service mesh) Session service, extracting, Case Study: Extracting Sessions Functionality to a Service-Case Study: Extracting Sessions Functionality to a Service, Case Study: A Look Back on Your Journey short-lived tokens, Encoding and verifying JSON Web Tokens sidecar proxies, What Is Service Mesh?service mesh implementation, Sidecars-Sidecars
Single Page Applications (SPAs), Authorization Code Grant single points of failure, API Gateway as a Single Point of Failure SOA (service-oriented architecture), Service-Oriented Architecture (SOA) software (see systems) software load balancers, Early 2000s Onward: Software Load Balancers-Early 2000s Onward: Software Load Balancers SPAs (Single Page Applications), Authorization Code Grant spoofing, Spoofing Spring Cloud Contracts, Contract testing frameworks storing contracts, API contracts storage and publishing strangler fig architectural pattern, Strangler Fig-Strangler Fig STRIDE methodologyDoS (denial of service), Denial of service-Rate limiting and load shedding elements of, Step 4: Identify Threats—Taking This in Your STRIDE-Step 4: Identify Threats—Taking This in Your STRIDE elevation of privilege, Elevation of Privilege information disclosure, Information disclosure-Improper assets management repudiation, Repudiation-Repudiation security misconfiguration, Security misconfiguration-Security directive hardening spoofing, Spoofing tampering, Tampering-Mass assignment
stub serversdefined, Why Contract Testing Is Often Preferable in integration testing, Using Stub Servers: Why and How-Using Stub Servers: Why and How
system-to-system authentication, System-to-System Authentication systems, evolvingwith APIsarchitectural patterns, Architectural Patterns for Evolving Systems with APIs-API Layer Cake benefits of, Why Use APIs to Evolve a System?-Case Study: Establishing Attendee Domain Boundaries change leverage points, Identifying Change Leverage Points within a System end state architectures, End State Architecture Options-Functions fitness functions, Using Fitness Functions-Using Fitness Functions goal setting, Determine Your Goals-Determine Your Goals module design, Decomposing a System into Modules-Decomposing a System into Modules pain points and opportunities, Identifying Pain Points and Opportunities-Breaking Dependencies: Highly Coupled APIs process management, Managing the Evolutionary Process-Continuous Delivery and Verification seams for extension, Creating APIs as “Seams” for Extension-Creating APIs as “Seams” for Extension
to cloud migrationAPI management in, Role of API Management-Role of API Management for Attendee API, Case Study: Moving the Attendee Service to the Cloud, Case Study: Replatforming the Attendee Service to the Cloud-Case Study: Replatforming the Attendee Service to the Cloud, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey strategies for, Choosing a Cloud Migration Strategy-Retire traffic management in, North–South Versus East–West: Blurring Lines of Traffic Management-Crossing Boundaries: Routing Across Networks
T tampering, Tampering-Mass assignment teaching, learning by, Learning by Teaching test pyramid strategy, Test Pyramid-Test Pyramid test quadrant strategy, Test Quadrant-Test Quadrant Testcontainers library, Containerizing Test Components: Testcontainers-Case Study: Applying Testcontainers to Verify Integrations testing APIscomponent testing, API Component Testing-Case Study: Component Test to Verify Behavior contract testingbenefits of, Why Contract Testing Is Often Preferable-Why Contract Testing Is Often Preferable contract implementation, How a Contract Is Implemented-API contracts storage and publishing frameworks for, Contract testing frameworks guidelines, ADR Guideline: Contract Testing-ADR Guideline: Contract Testing terminology, Contract Testing
end-to-end testingautomating, Automating End-to-End Validation-Automating End-to-End Validation defined, Test Pyramid guidelines, ADR Guideline: End-to-End Testing-ADR Guideline: End-to-End Testing purpose of, End-to-End Testing types of tests, Types of End-to-End Tests-Types of End-to-End Tests
importance of, Testing APIs integration testing, API Integration Testingguidelines, ADR Guideline: Integration Testing stub servers in, Using Stub Servers: Why and How-Using Stub Servers: Why and How Testcontainers library, Containerizing Test Components: Testcontainers-Case Study: Applying Testcontainers to Verify Integrations
scenario testing, How a Contract Is Implemented, Types of End-to-End Tests service testing, Test Pyramid strategiesguidelines, ADR Guideline for Testing Strategies importance of, Testing Strategies test pyramid, Test Pyramid-Test Pyramid test quadrant, Test Quadrant-Test Quadrant
UI testing, Test Pyramid unit testing, Test Pyramid
Thoughtworks Technology Radar, Separating Deployment and Release threat detection/mitigation, Protect APIs from Overuse and Abuse: Threat Detection and Mitigation-Protect APIs from Overuse and Abuse: Threat Detection and Mitigation threat modelingAttendee API, Case Study: Applying OWASP to the Attendee API-Case Study: Applying OWASP to the Attendee API, Case Study: A Look Back on Your Journey-Case Study: A Look Back on Your Journey defined, Threat Modeling 101 DFDs (data flow diagrams), Threat Modeling 101-Threat Modeling 101, Step 3: Decompose the System evaluating risks, Step 5: Evaluate Threat Risks-Step 5: Evaluate Threat Risks gathering information, Step 2: Gather the Right Information identifying objectives, Step 1: Identify Your Objectives steps in, How to Threat Model STRIDE methodologyDoS (denial of service), Denial of service-Rate limiting and load shedding elements of, Step 4: Identify Threats—Taking This in Your STRIDE-Step 4: Identify Threats—Taking This in Your STRIDE elevation of privilege, Elevation of Privilege information disclosure, Information disclosure-Improper assets management repudiation, Repudiation-Repudiation security misconfiguration, Security misconfiguration-Security directive hardening spoofing, Spoofing tampering, Tampering-Mass assignment
thinking like attacker, Thinking Like an Attacker validating, Step 6: Validation
tight coupling, Breaking Dependencies: Highly Coupled APIs TLS termination, TLS termination token-based authentication, End-User Authentication with Tokens-End-User Authentication with Tokensmixing with key-based, Why You Shouldn’t Mix Keys and Users
traces, Three Pillars of Observability traditional enterprise API gateways, Traditional Enterprise Gateways traffic managementAPI gatewaysbenefits of, Why Use an API Gateway?-Monetize APIs: Account Management, Billing, and Payment configuring Mappings, Configuring Mappings from URL Paths to Backend Services-Configuring Mappings Using Host-based Routing defined, What Is an API Gateway? deployment location, Where Is an API Gateway Deployed?-Where Is an API Gateway Deployed? edge proxies and ingress controllers versus, 2015 Onward: Second-Generation API Gateways failure management, Deploying API Gateways: Understanding and Managing Failure-Mitigating Risks history of, A Modern History of API Gateways-2015 Onward: Second-Generation API Gateways implementation pitfalls, Common API Gateway Implementation Pitfalls-Turtles (API Gateways) All the Way Down installing, Installing Ambassador Edge Stack in Kubernetes integration with edge technologies, How Does an API Gateway Integrate with Other Technologies at the Edge?-How Does an API Gateway Integrate with Other Technologies at the Edge? purpose of, What Functionality Does an API Gateway Provide? reverse proxies and load balancers versus, Is an API Gateway the Only Solution?-Guideline: Proxy, Load Balancer, or API Gateway selecting, Selecting an API Gateway-ADR Guideline: Selecting an API Gateway types of, Current API Gateway Taxonomy-Comparing API Gateway Types
in cloud migration, North–South Versus East–West: Blurring Lines of Traffic Management-Crossing Boundaries: Routing Across Networks defined, API Infrastructure and Traffic Patterns separating release and deployment, Traffic Management-Traffic Management service meshbenefits of, Why Use a Service Mesh?-Separating Ingress and Service-to-Service Traffic Management defined, What Is Service Mesh?-What Is Service Mesh? deployment location, Where Is a Service Mesh Deployed? failure management, Deploying a Service Mesh: Understanding and Managing Failure history of, Evolution of Service Mesh-Early History and Motivations implementation patterns, Implementation Patterns-Service Mesh Taxonomy implementation pitfalls, Common Service Mesh Implementation Challenges-Too Many Networking Layers integration with networking technologies, How Does a Service Mesh Integrate with Other Networking Technologies?-How Does a Service Mesh Integrate with Other Networking Technologies? libraries versus, Is Service Mesh the Only Solution?-Guideline: Should You Adopt Service Mesh? network segmentation with Consul, Network Segmentation with Consul-Network Segmentation with Consul observing with Linkerd, Observing Traffic with Linkerd-Observing Traffic with Linkerd purpose of, What Functionality Does a Service Mesh Provide?-What Functionality Does a Service Mesh Provide? routing with Istio, Routing with Istio-Routing with Istio selecting, Selecting a Service Mesh-Checklist: Selecting a Service Mesh
traffic mirroring, Traffic Mirroring-Traffic Mirroring traffic patternsAPI infrastructure and, API Infrastructure and Traffic Patterns in conference system case study, Case Study: An Evolutionary Step-East–west traffic, Case Study: A Look Back on Your Journey modeling exchanges, Modeling Exchanges and Choosing an API Formatguidelines for, Guideline: Modeling Exchanges high-traffic services, High-Traffic Services HTTP/2 performance, HTTP/2 Performance Benefits large payloads, Large Exchange Payloads-Large Exchange Payloads vintage components, Vintage Formats
purpose of, From Tiered Architecture to Modeling APIs
traffic policing, Traffic policing traffic shaping, Traffic shaping translating backend services, Simplify Consumption: Aggregating/Translating Backend Services-Simplify Consumption: Aggregating/Translating Backend Services Type 1 decisions, Understanding Decision Types Type 2 decisions, Understanding Decision Types
U UI testing, Test Pyramid UML (Unified Modeling Language), Using C4 Diagrams unit testing, Test Pyramid upgrade issues when evolving systems, Upgrade and Maintenance Issues use cases, Learning About Best Practices and Use Cases-Learning About Best Practices and Use Cases
V validatingthreat modeling, Step 6: Validation with OAS, OpenAPI Validation-OpenAPI Validation
versioning APIsOAS and, OpenAPI Specification and Versioning-OpenAPI Specification and Versioning options for, API Versioning-API Versioning semantic versioning, Semantic Versioning
vintage components, Vintage Formats
W WAFs (web application firewalls), Early 2000s Onward: Software Load Balancers
Z zero trust architectureprinciples of, Trust No One and Verify-Trust No One and Verify service mesh in, Role of Service Mesh in Zero Trust Architectures-Augmenting Service Mesh with Network Policies
zonal architecture, Getting in the Zone-Getting in the Zone
About the Authors James Gough is a Distinguished Engineer at Morgan Stanley working on API architecture and API programs. He is a Java Champion who has sat on the Java Community Process Executive Committee on behalf of the London Java Community and contributed to OpenJDK. James is also coauthor of Optimizing Java and enjoys speaking about architecture and low-level Java. Daniel Bryant is the head of developer relations at Ambassador Labs. When it comes to job roles, he subscribes to the Pokémon philosophy of “gotta catch ’em all,” and in previous lives, Daniel has worked as an academic, developer, architect, platform engineer, consultant, and CTO. His technical expertise focuses on DevOps tooling, cloud/container platforms, and microservice implementations. Daniel is a Java Champion and contributes to several open source projects. He also writes for InfoQ, O’Reilly, and The New Stack, and regularly presents at international conferences such as KubeCon, QCon, and Devoxx. In his copious amounts of free time, he enjoys running, reading, and traveling. Matthew Auburn has worked for Morgan Stanley on a variety of financial systems. Before working at Morgan Stanley, he built a variety of mobile and web applications. Matthew’s master’s degree primarily focused on security, and this has fed into working in the security space for building APIs.
Colophon The animal on the cover of Mastering API Architecture is an armadillo girdled lizard (Ouroborus cataphractus), previously in the genus Cordylus. Armadillo girdled lizards live in the desert on the western coast of south Africa. They are often compared to miniature dragons in appearance: light or dark brown scales and yellow underbellies with black patterns. As far as size, they are typically between 7.5 and 9 centimeters in snout vent length (which does not include the tail). They live in groups and are active during the day, although most of their active time is spent sunbathing. Their diet consists primarily of small insects (mostly termites), and they brumate (go into partial hibernation) during the winter. Unlike most lizards, which lay eggs, armadillo girdled lizards give birth to live young, one or two at a time about once a year. The females may also feed their young, another unusual behavior for lizards. Their defense mechanism against predators is to roll into a ball and hold their tails in their mouths. This makes them look like mythical ouroboros, which is a symbol of wholeness or infinity. This unique behavior is the reason for their name, as mammalian armadillos also curl up in a ball. The conservation status of the armadillo girdled lizard is “near threatened.” Many of the animals on O’Reilly covers are endangered; all of them are important to the world. The cover illustration is by Karen Montgomery, based on a black-and-white engraving from the Museum of Natural History. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.
